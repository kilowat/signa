{
  "version": 3,
  "sources": ["../node_modules/udomdiff/esm/index.js", "../node_modules/uhtml/esm/utils.js", "../node_modules/domconstants/esm/constants.js", "../node_modules/custom-function/esm/factory.js", "../node_modules/uhtml/esm/range.js", "../node_modules/uhtml/esm/persistent-fragment.js", "../node_modules/uhtml/esm/handler.js", "../node_modules/uhtml/esm/literals.js", "../node_modules/uhtml/esm/creator.js", "../node_modules/domconstants/esm/re.js", "../node_modules/@webreflection/uparser/esm/index.js", "../node_modules/uhtml/esm/create-content.js", "../node_modules/uhtml/esm/parser.js", "../node_modules/uhtml/esm/rabbit.js", "../node_modules/uhtml/esm/index.js", "../node_modules/uhtml/esm/render/shared.js", "../node_modules/uhtml/esm/keyed.js", "../node_modules/gc-hook/esm/index.js", "../node_modules/uhtml/esm/render/reactive.js", "../node_modules/@preact/signals-core/src/index.ts", "../src/core/state.ts", "../src/core/untils.ts", "../src/core/store.ts", "../src/core/component.ts", "../src/core/styles-registry.ts", "../src/core/component-styles.ts", "../src/components/button/styles.ts", "../src/components/button/button.ts"],
  "sourcesContent": ["/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -0).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -0).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "const { isArray } = Array;\nconst { getPrototypeOf, getOwnPropertyDescriptor } = Object;\n\nexport { isArray };\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const empty = [];\n\nexport const newRange = () => document.createRange();\n\n/**\n * Set the `key` `value` pair to the *Map* or *WeakMap* and returns the `value`\n * @template T\n * @param {Map | WeakMap} map\n * @param {any} key\n * @param {T} value\n * @returns {T}\n */\nexport const set = (map, key, value) => {\n  map.set(key, value);\n  return value;\n};\n\n/**\n * Return a descriptor, if any, for the referenced *Element*\n * @param {Element} ref\n * @param {string} prop\n * @returns \n */\nexport const gPD = (ref, prop) => {\n  let desc;\n  do { desc = getOwnPropertyDescriptor(ref, prop); }\n  while(!desc && (ref = getPrototypeOf(ref)));\n  return desc;\n};\n\n/* c8 ignore start */\n/**\n * @param {DocumentFragment} content\n * @param {number[]} path\n * @returns {Element}\n */\nexport const find = (content, path) => path.reduceRight(childNodesIndex, content);\nconst childNodesIndex = (node, i) => node.childNodes[i];\n/* c8 ignore stop */\n", "export const ELEMENT_NODE = 1;\nexport const ATTRIBUTE_NODE = 2;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n", "const {setPrototypeOf} = Object;\n\n/**\n * @param {Function} Class any base class to extend without passing through it via super() call.\n * @returns {Function} an extensible class for the passed one.\n * @example\n *  // creating this very same module utility\n *  import custom from 'custom-function/factory';\n *  const CustomFunction = custom(Function);\n *  class MyFunction extends CustomFunction {}\n *  const mf = new MyFunction(() => {});\n */\nexport default Class => {\n  function Custom(target) {\n    return setPrototypeOf(target, new.target.prototype);\n  }\n  Custom.prototype = Class.prototype;\n  return Custom;\n};\n", "import { newRange } from './utils.js';\n\nlet range;\n/**\n * @param {Node | Element} firstChild\n * @param {Node | Element} lastChild\n * @param {boolean} preserve\n * @returns\n */\nexport default (firstChild, lastChild, preserve) => {\n  if (!range) range = newRange();\n  /* c8 ignore start */\n  if (preserve)\n    range.setStartAfter(firstChild);\n  else\n    range.setStartBefore(firstChild);\n  /* c8 ignore stop */\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n", "import { DOCUMENT_FRAGMENT_NODE } from 'domconstants/constants';\nimport custom from 'custom-function/factory';\nimport drop from './range.js';\nimport { empty } from './utils.js';\n\n/**\n * @param {PersistentFragment} fragment\n * @returns {Node | Element}\n */\nconst remove = ({firstChild, lastChild}, preserve) => drop(firstChild, lastChild, preserve);\n\nlet checkType = false;\n\n/**\n * @param {Node} node\n * @param {1 | 0 | -0 | -1} operation\n * @returns {Node}\n */\nexport const diffFragment = (node, operation) => (\n  checkType && node.nodeType === DOCUMENT_FRAGMENT_NODE ?\n    ((1 / operation) < 0 ?\n      (operation ? remove(node, true) : node.lastChild) :\n      (operation ? node.valueOf() : node.firstChild)) :\n    node\n);\n\nconst comment = value => document.createComment(value);\n\n/** @extends {DocumentFragment} */\nexport class PersistentFragment extends custom(DocumentFragment) {\n  #firstChild = comment('<>');\n  #lastChild = comment('</>');\n  #nodes = empty;\n  constructor(fragment) {\n    super(fragment);\n    this.replaceChildren(...[\n      this.#firstChild,\n      ...fragment.childNodes,\n      this.#lastChild,\n    ]);\n    checkType = true;\n  }\n  get firstChild() { return this.#firstChild; }\n  get lastChild() { return this.#lastChild; }\n  get parentNode() { return this.#firstChild.parentNode; }\n  remove() {\n    remove(this, false);\n  }\n  replaceWith(node) {\n    remove(this, true).replaceWith(node);\n  }\n  valueOf() {\n    const { parentNode } = this;\n    if (parentNode === this) {\n      if (this.#nodes === empty)\n        this.#nodes = [...this.childNodes];\n    }\n    else {\n      /* c8 ignore start */\n      // there are cases where a fragment might be just appended\n      // out of the box without valueOf() invoke (first render).\n      // When these are moved around and lose their parent and,\n      // such parent is not the fragment itself, it's possible there\n      // where changes or mutations in there to take care about.\n      // This is a render-only specific issue but it's tested and\n      // it's worth fixing to me to have more consistent fragments.\n      if (parentNode) {\n        let { firstChild, lastChild } = this;\n        this.#nodes = [firstChild];\n        while (firstChild !== lastChild)\n          this.#nodes.push((firstChild = firstChild.nextSibling));\n      }\n      /* c8 ignore stop */\n      this.replaceChildren(...this.#nodes);\n    }\n    return this;\n  }\n}\n", "import udomdiff from 'udomdiff';\nimport { empty, gPD, isArray, set } from './utils.js';\nimport { diffFragment } from './persistent-fragment.js';\nimport drop from './range.js';\n\nconst setAttribute = (element, name, value) =>\n  element.setAttribute(name, value);\n\n/**\n * @param {Element} element\n * @param {string} name\n * @returns {void}\n */\nexport const removeAttribute = (element, name) =>\n  element.removeAttribute(name);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const aria = (element, value) => {\n  for (const key in value) {\n    const $ = value[key];\n    const name = key === 'role' ? key : `aria-${key}`;\n    if ($ == null) removeAttribute(element, name);\n    else setAttribute(element, name, $);\n  }\n  return value;\n};\n\nlet listeners;\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const at = (element, value, name) => {\n  name = name.slice(1);\n  if (!listeners) listeners = new WeakMap;\n  const known = listeners.get(element) || set(listeners, element, {});\n  let current = known[name];\n  if (current && current[0]) element.removeEventListener(name, ...current);\n  current = isArray(value) ? value : [value, false];\n  known[name] = current;\n  if (current[0]) element.addEventListener(name, ...current);\n  return value;\n};\n\n/** @type {WeakMap<Node, Element | import(\"./persistent-fragment.js\").PersistentFragment>} */\nconst holes = new WeakMap;\n\n/**\n * @template T\n * @param {import(\"./literals.js\").Detail} detail\n * @param {T} value\n * @returns {T}\n */\nexport const hole = (detail, value) => {\n  const { t: node, n: hole } = detail;\n  let nullish = false;\n  switch (typeof value) {\n    case 'object':\n      if (value !== null) {\n        (hole || node).replaceWith((detail.n = value.valueOf()));\n        break;\n      }\n    case 'undefined':\n      nullish = true;\n    default:\n      node.data = nullish ? '' : value;\n      if (hole) {\n        detail.n = null;\n        hole.replaceWith(node);\n      }\n      break;\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const className = (element, value) => maybeDirect(\n  element, value, value == null ? 'class' : 'className'\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const data = (element, value) => {\n  const { dataset } = element;\n  for (const key in value) {\n    if (value[key] == null) delete dataset[key];\n    else dataset[key] = value[key];\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element | CSSStyleDeclaration} ref\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const direct = (ref, value, name) => (ref[name] = value);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const dot = (element, value, name) => direct(element, value, name.slice(1));\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const maybeDirect = (element, value, name) => (\n  value == null ?\n    (removeAttribute(element, name), value) :\n    direct(element, value, name)\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const ref = (element, value) => (\n  (typeof value === 'function' ?\n    value(element) : (value.current = element)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nconst regular = (element, value, name) => (\n  (value == null ?\n    removeAttribute(element, name) :\n    setAttribute(element, name, value)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const style = (element, value) => (\n  value == null ?\n    maybeDirect(element, value, 'style') :\n    direct(element.style, value, 'cssText')\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const toggle = (element, value, name) => (\n  element.toggleAttribute(name.slice(1), value),\n  value\n);\n\n/**\n * @param {Node} node\n * @param {Node[]} value\n * @param {string} _\n * @param {Node[]} prev\n * @returns {Node[]}\n */\nexport const array = (node, value, prev) => {\n  // normal diff\n  const { length } = value;\n  node.data = `[${length}]`;\n  if (length)\n    return udomdiff(node.parentNode, prev, value, diffFragment, node);\n  /* c8 ignore start */\n  switch (prev.length) {\n    case 1:\n      prev[0].remove();\n    case 0:\n      break;\n    default:\n      drop(\n        diffFragment(prev[0], 0),\n        diffFragment(prev.at(-1), -0),\n        false\n      );\n      break;\n  }\n  /* c8 ignore stop */\n  return empty;\n};\n\nexport const attr = new Map([\n  ['aria', aria],\n  ['class', className],\n  ['data', data],\n  ['ref', ref],\n  ['style', style],\n]);\n\n/**\n * @param {HTMLElement | SVGElement} element\n * @param {string} name\n * @param {boolean} svg\n * @returns\n */\nexport const attribute = (element, name, svg) => {\n  switch (name[0]) {\n    case '.': return dot;\n    case '?': return toggle;\n    case '@': return at;\n    default: return (\n      svg || ('ownerSVGElement' in element) ?\n        (name === 'ref' ? ref : regular) :\n        (attr.get(name) || (\n          name in element ?\n            (name.startsWith('on') ?\n              direct :\n              (gPD(element, name)?.set ? maybeDirect : regular)\n            ) :\n            regular\n          )\n        )\n    );\n  }\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const text = (element, value) => (\n  (element.textContent = value == null ? '' : value),\n  value\n);\n", "import { empty } from './utils.js';\n\n/** @typedef {import(\"./persistent-fragment.js\").PersistentFragment} PersistentFragment */\n/** @typedef {import(\"./rabbit.js\").Hole} Hole */\n\n/** @typedef {unknown} Value */\n/** @typedef {Node | Element | PersistentFragment} Target */\n/** @typedef {null | undefined | string | number | boolean | Node | Element | PersistentFragment} DOMValue */\n/** @typedef {Hole | Node} ArrayValue */\n\nexport const abc = (a, b, c) => ({ a, b, c });\n\nexport const bc = (b, c) => ({ b, c });\n\n/**\n * @typedef {Object} Detail\n * @property {any} v the current value of the interpolation / hole\n * @property {function} u the callback to update the value\n * @property {Node} t the target comment node or element\n * @property {string | null | Node} n the attribute name, if any, or `null`\n * @property {Cache | ArrayValue[] | null} c the cache value for this detail\n */\n\n/**\n * @returns {Detail}\n */\nexport const detail = (u, t, n, c) => ({ v: empty, u, t, n, c });\n\n/**\n * @typedef {Object} Entry\n * @property {number[]} a the path to retrieve the node\n * @property {function} b the update function\n * @property {string | null} c the attribute name, if any, or `null`\n */\n\n/**\n * @typedef {Object} Cache\n * @property {null | TemplateStringsArray} a the cached template\n * @property {null | Node | PersistentFragment} b the node returned when parsing the template\n * @property {Detail[]} c the list of updates to perform\n */\n\n/**\n * @returns {Cache}\n */\nexport const cache = () => abc(null, null, empty);\n", "import { PersistentFragment } from './persistent-fragment.js';\nimport { bc, detail } from './literals.js';\nimport { array, hole } from './handler.js';\nimport { empty, find } from './utils.js';\nimport { cache } from './literals.js';\n\n/** @param {(template: TemplateStringsArray, values: any[]) => import(\"./parser.js\").Resolved} parse */\nexport default parse => (\n  /**\n   * @param {TemplateStringsArray} template\n   * @param {any[]} values\n   * @returns {import(\"./literals.js\").Cache}\n   */\n  (template, values) => {\n    const { a: fragment, b: entries, c: direct } = parse(template, values);\n    const root = document.importNode(fragment, true);\n    /** @type {import(\"./literals.js\").Detail[]} */\n    let details = empty;\n    if (entries !== empty) {\n      details = [];\n      for (let current, prev, i = 0; i < entries.length; i++) {\n        const { a: path, b: update, c: name } = entries[i];\n        const node = path === prev ? current : (current = find(root, (prev = path)));\n        details[i] = detail(\n          update,\n          node,\n          name,\n          update === array ? [] : (update === hole ? cache() : null)\n        );\n      }\n    }\n    return bc(\n      direct ? root.firstChild : new PersistentFragment(root),\n      details,\n    );\n  }\n);\n", "export const TEXT_ELEMENTS = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\nexport const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n", "import { VOID_ELEMENTS } from 'domconstants/re';\n\nconst elements = /<([a-zA-Z0-9]+[a-zA-Z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} xml enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, xml) => {\n  let i = 0;\n  return template\n    .join('\\x01')\n    .trim()\n    .replace(\n      elements,\n      (_, name, attrs, selfClosing) => `<${\n          name\n        }${\n          attrs.replace(attributes, '\\x02=$2$1').trimEnd()\n        }${\n          selfClosing ? (\n            (xml || VOID_ELEMENTS.test(name)) ? ' /' : `></${name}`\n          ) : ''\n        }>`\n    )\n    .replace(\n      holes,\n      hole => hole === '\\x01' ? `<!--${prefix + i++}-->` : (prefix + i++)\n    )\n  ;\n};\n", "import { SVG_NAMESPACE, newRange } from './utils.js';\n\nlet template = document.createElement('template'), svg, range;\n\n/**\n * @param {string} text\n * @param {boolean} xml\n * @returns {DocumentFragment}\n */\nexport default (text, xml) => {\n  if (xml) {\n    if (!svg) {\n      svg = document.createElementNS(SVG_NAMESPACE, 'svg');\n      range = newRange();\n      range.selectNodeContents(svg);\n    }\n    return range.createContextualFragment(text);\n  }\n  template.innerHTML = text;\n  const { content } = template;\n  template = template.cloneNode(false);\n  return content;\n};\n", "import { COMMENT_NODE, ELEMENT_NODE } from 'domconstants/constants';\nimport { TEXT_ELEMENTS } from 'domconstants/re';\nimport parser from '@webreflection/uparser';\n\nimport { empty, isArray, set } from './utils.js';\nimport { abc } from './literals.js';\n\nimport { array, attribute, hole, text, removeAttribute } from './handler.js';\nimport createContent from './create-content.js';\n\n/** @typedef {import(\"./literals.js\").Entry} Entry */\n\n/**\n * @typedef {Object} Resolved\n * @param {DocumentFragment} f content retrieved from the template\n * @param {Entry[]} e entries per each hole in the template\n * @param {boolean} d direct node to handle\n */\n\n/**\n * @param {Element} node\n * @returns {number[]}\n */\nconst createPath = node => {\n  const path = [];\n  let parentNode;\n  while ((parentNode = node.parentNode)) {\n    path.push(path.indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n  }\n  return path;\n};\n\nconst textNode = () => document.createTextNode('');\n\n/**\n * @param {TemplateStringsArray} template\n * @param {boolean} xml\n * @returns {Resolved}\n */\nconst resolve = (template, values, xml) => {\n  const content = createContent(parser(template, prefix, xml), xml);\n  const { length } = template;\n  let entries = empty;\n  if (length > 1) {\n    const replace = [];\n    const tw = document.createTreeWalker(content, 1 | 128);\n    let i = 0, search = `${prefix}${i++}`;\n    entries = [];\n    while (i < length) {\n      const node = tw.nextNode();\n      // these are holes or arrays\n      if (node.nodeType === COMMENT_NODE) {\n        if (node.data === search) {\n          // \u26A0\uFE0F once array, always array!\n          const update = isArray(values[i - 1]) ? array : hole;\n          if (update === hole) replace.push(node);\n          entries.push(abc(createPath(node), update, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n      else {\n        let path;\n        // these are attributes\n        while (node.hasAttribute(search)) {\n          if (!path) path = createPath(node);\n          const name = node.getAttribute(search);\n          entries.push(abc(path, attribute(node, name, xml), name));\n          removeAttribute(node, search);\n          search = `${prefix}${i++}`;\n        }\n        // these are special text-only nodes\n        if (\n          !xml &&\n          TEXT_ELEMENTS.test(node.localName) &&\n          node.textContent.trim() === `<!--${search}-->`\n        ) {\n          entries.push(abc(path || createPath(node), text, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n    }\n    // can't replace holes on the fly or the tree walker fails\n    for (i = 0; i < replace.length; i++)\n      replace[i].replaceWith(textNode());\n  }\n\n  // need to decide if there should be a persistent fragment\n  const { childNodes } = content;\n  let { length: len } = childNodes;\n\n  // html`` or svg`` to signal an empty content\n  // these nodes can be passed directly as never mutated\n  if (len < 1) {\n    len = 1;\n    content.appendChild(textNode());\n  }\n  // html`${'b'}` or svg`${[]}` cases\n  else if (\n    len === 1 &&\n    // ignore html`static` or svg`static` because\n    // these nodes can be passed directly as never mutated\n    length !== 1 &&\n    childNodes[0].nodeType !== ELEMENT_NODE\n  ) {\n    // use a persistent fragment for these cases too\n    len = 0;\n  }\n\n  return set(cache, template, abc(content, entries, len === 1));\n};\n\n/** @type {WeakMap<TemplateStringsArray, Resolved>} */\nconst cache = new WeakMap;\nconst prefix = 'is\u00B5';\n\n/**\n * @param {boolean} xml\n * @returns {(template: TemplateStringsArray, values: any[]) => Resolved}\n */\nexport default xml => (template, values) => cache.get(template) || resolve(template, values, xml);\n", "import { array, hole } from './handler.js';\nimport { cache } from './literals.js';\nimport create from './creator.js';\nimport parser from './parser.js';\n\nconst createHTML = create(parser(false));\nconst createSVG = create(parser(true));\n\n/**\n * @param {import(\"./literals.js\").Cache} info\n * @param {Hole} hole\n * @returns {Node}\n */\nconst unroll = (info, { s, t, v }) => {\n  if (info.a !== t) {\n    const { b, c } = (s ? createSVG : createHTML)(t, v);\n    info.a = t;\n    info.b = b;\n    info.c = c;\n  }\n  for (let { c } = info, i = 0; i < c.length; i++) {\n    const value = v[i];\n    const detail = c[i];\n    switch (detail.u) {\n      case array:\n        detail.v = array(\n          detail.t,\n          unrollValues(detail.c, value),\n          detail.v\n        );\n        break;\n      case hole:\n        const current = value instanceof Hole ?\n          unroll(detail.c || (detail.c = cache()), value) :\n          (detail.c = null, value)\n        ;\n        if (current !== detail.v)\n          detail.v = hole(detail, current);\n        break;\n      default:\n        if (value !== detail.v)\n          detail.v = detail.u(detail.t, value, detail.n, detail.v);\n        break;\n    }\n  }\n  return info.b;\n};\n\n/**\n * @param {Cache} cache\n * @param {any[]} values\n * @returns {number}\n */\nconst unrollValues = (stack, values) => {\n  let i = 0, { length } = values;\n  if (length < stack.length) stack.splice(length);\n  for (; i < length; i++) {\n    const value = values[i];\n    if (value instanceof Hole)\n      values[i] = unroll(stack[i] || (stack[i] = cache()), value);\n    else stack[i] = null;\n  }\n  return values;\n};\n\n/**\n * Holds all details needed to render the content on a render.\n * @constructor\n * @param {boolean} svg The content type.\n * @param {TemplateStringsArray} template The template literals used to the define the content.\n * @param {any[]} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(svg, template, values) {\n    this.s = svg;\n    this.t = template;\n    this.v = values;\n  }\n  toDOM(info = cache()) {\n    return unroll(info, this);\n  }\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\n\nimport render from './render/hole.js';\n\n/** @typedef {import(\"./literals.js\").Value} Value */\n\nconst tag = svg => (template, ...values) => new Hole(svg, template, values);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render HTML content. */\nexport const html = tag(false);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render SVG content. */\nexport const svg = tag(true);\n\nexport { Hole, render, attr };\n", "import { Hole } from '../rabbit.js';\nimport { cache } from '../literals.js';\nimport { set } from '../utils.js';\n\n/** @type {WeakMap<Element | DocumentFragment, import(\"../literals.js\").Cache>} */\nconst known = new WeakMap;\n\n/**\n  * Render with smart updates within a generic container.\n  * @template T\n  * @param {T} where the DOM node where to render content\n  * @param {(() => Hole) | Hole} what the hole to render\n  * @param {boolean} check does a `typeof` check (internal usage).\n  * @returns\n  */\nexport default (where, what, check) => {\n  const info = known.get(where) || set(known, where, cache());\n  const { b } = info;\n  const hole = (check && typeof what === 'function') ? what() : what;\n  const node = hole instanceof Hole ? hole.toDOM(info) : hole;\n  if (b !== node)\n    where.replaceChildren((info.b = node).valueOf());\n  return where;\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\nimport { cache } from './literals.js';\nimport { set } from './utils.js';\nimport { html, svg } from './index.js';\n\nimport render from './render/keyed.js';\n\n/** @typedef {import(\"./literals.js\").Cache} Cache */\n/** @typedef {import(\"./literals.js\").Target} Target */\n/** @typedef {import(\"./literals.js\").Value} Value */\n\n/** @typedef {(ref:Object, key:string | number) => Tag} Bound */\n\n/**\n * @callback Tag\n * @param {TemplateStringsArray} template\n * @param  {...Value} values\n * @returns {Target}\n */\n\nconst keyed = new WeakMap;\nconst createRef = svg => /** @type {Bound} */ (ref, key) => {\n  /** @type {Tag} */\n  function tag(template, ...values) {\n    return new Hole(svg, template, values).toDOM(this);\n  }\n\n  const memo = keyed.get(ref) || set(keyed, ref, new Map);\n  return memo.get(key) || set(memo, key, tag.bind(cache()));\n};\n\n/** @type {Bound} Returns a bound tag to render HTML content. */\nexport const htmlFor = createRef(false);\n\n/** @type {Bound} Returns a bound tag to render SVG content. */\nexport const svgFor = createRef(true);\n\nexport { Hole, render, html, svg, attr };\n", "// (c) Andrea Giammarchi - ISC\n\nconst registry = new FinalizationRegistry(\n  ([onGarbageCollected, held, debug]) => {\n    // \"%cThis is a green text\", \"color:green\"\n    if (debug) console.debug(`%c${String(held)}`, 'font-weight:bold', 'collected');\n    onGarbageCollected(held);\n  }\n);\n\nconst nullHandler = Object.create(null);\n\n/**\n * @template {unknown} H\n * @typedef {Object} GCHookOptions\n * @prop {boolean} [debug=false] if `true`, logs values once these can get collected.\n * @prop {ProxyHandler<object>} [handler] optional proxy handler to use instead of the default one.\n * @prop {H} [return=H] if specified, overrides the returned proxy with its value.\n * @prop {unknown} [token=H] it's the held value by default, but it can be any other token except the returned value itself.\n */\n\n/**\n * @template {unknown} H\n * @param {H} hold the reference to hold behind the scene and passed along the callback once it triggers.\n * @param {(held:H) => void} onGarbageCollected the callback that will receive the held value once its wrapper or indirect reference is no longer needed.\n * @param {GCHookOptions<H>} [options] an optional configuration object to change some default behavior.\n */\nexport const create = (\n  hold,\n  onGarbageCollected,\n  { debug, handler, return: r, token = hold } = nullHandler\n) => {\n  // if no reference to return is defined,\n  // create a proxy for the held one and register that instead.\n  /** @type {H} */\n  const target = r || new Proxy(hold, handler || nullHandler);\n  const args = [target, [onGarbageCollected, hold, !!debug]];\n  if (token !== false) args.push(token);\n  // register the target reference in a way that\n  // the `onGarbageCollected(held)` callback will eventually notify.\n  registry.register(...args);\n  return target;\n};\n\n/**\n * If previously registered as either `token` or `hold` value, allow explicit removal of the entry in the registry.\n * @param {unknown} token the token used during registration. If no `token` was passed, this can be the same `hold` reference.\n * @returns {boolean} `true` if successfully unregistered.\n */\nexport const drop = token => registry.unregister(token);\n", "import { create, drop } from 'gc-hook';\n\nimport render from './shared.js';\n\n/** @typedef {import(\"../rabbit.js\").Hole} Hole */\n\n/** @type {WeakMap<Element | DocumentFragment, Function>} */\nconst effects = new WeakMap;\n\n/**\n * @param {Function} dispose\n * @returns {void}\n */\nconst onGC = dispose => dispose();\n\nlet remove = true;\n\n/**\n * @param {Function} effect the reactive `effect` callback provided by a 3rd party library.\n * @returns \n */\nexport const attach = effect => {\n  /**\n   * Render with smart updates within a generic container.\n   * If the `what` is a function, it automatically create\n   * an effect for the render function.\n   * @template T\n   * @param {T} where the DOM node where to render content\n   * @param {(() => Hole) | Hole} what the hole to render\n   * @returns {T}\n   */\n  return (where, what) => {\n    remove = typeof what !== 'function';\n    detach(where);\n\n    if (remove) return render(where, what, false);\n    remove = true;\n\n    const wr = new WeakRef(where);\n    const dispose = effect(() => { render(wr.deref(), what(), false) });\n    effects.set(where, dispose);\n    return create(dispose, onGC, { return: where });\n  };\n};\n\n/**\n * Allow manual cleanup of subscribed signals.\n * @param {Element} where a reference container previously used to render signals.\n */\nexport const detach = where => {\n  const dispose = effects.get(where);\n  if (dispose) {\n    if (remove) effects.delete(where);\n    drop(dispose);\n    dispose();\n  }\n};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(() => {\n\t\tconst value = this.value;\n\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n\treturn new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(fn: EffectFn);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n\tconst effect = new Effect(fn);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { computed, effect, batch, untracked, Signal, ReadonlySignal };\n", "import { ReadonlySignal, Signal, signal as createSignal, computed as preactComputed } from '@preact/signals-core';\r\nimport { ComputedProperties } from './component';\r\n\r\n\r\nexport class State<T> extends Signal<T> {\r\n    emit(value: Partial<T> | T): void {\r\n        if (typeof value === 'object' && value !== null && typeof this.value === 'object') {\r\n            const currentClone = cloneDeep(this.value);\r\n            this.value = { ...currentClone, ...value } as T;\r\n        } else {\r\n            this.value = value as T;\r\n        }\r\n    }\r\n}\r\n\r\nexport function createState<T>(initialValue: T): State<T> {\r\n    const baseSignal = createSignal(initialValue);\r\n    Object.setPrototypeOf(baseSignal, State.prototype);\r\n    return baseSignal as State<T>;\r\n}\r\n\r\n\r\nfunction cloneDeep<T>(obj: T): T {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n        return obj.map(cloneDeep) as unknown as T;\r\n    }\r\n\r\n    const clonedObj: Record<PropertyKey, any> = {};\r\n    for (const key of Reflect.ownKeys(obj)) {\r\n        clonedObj[key as keyof typeof obj] = cloneDeep((obj as Record<PropertyKey, any>)[key]);\r\n    }\r\n\r\n    return clonedObj as T;\r\n}\r\n\r\nexport type ComputedResult<T, Args extends any[]> = (...args: Args) => T;\r\n\r\nexport function compute<R, Args extends any[]>(\r\n    computeFn: (...args: Args) => R\r\n): ComputedResult<R, Args> {\r\n    return (...args: Args) => {\r\n        const signal = preactComputed(() => computeFn(...args));\r\n        return signal.value;\r\n    };\r\n}\r\n\r\n\r\nexport function createComputed<C extends Record<string, (...args: any[]) => any>>(\r\n    computedFn: () => C\r\n): ComputedProperties<C> {\r\n    const computedSignals = new Map<string, any>();\r\n    const computedCache = new Map<string, Map<string, any>>(); // \u041A\u044D\u0448 \u0434\u043B\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0439 \u0441 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430\u043C\u0438\r\n\r\n    const computed = Object.entries(computedFn()).reduce((acc, [key, fn]) => {\r\n        if (fn.length === 0) {\r\n            // \u041A\u044D\u0448\u0438\u0440\u0443\u0435\u043C \u0432\u044B\u0447\u0438\u0441\u043B\u0435\u043D\u0438\u044F \u0431\u0435\u0437 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432\r\n            if (!computedSignals.has(key)) {\r\n                computedSignals.set(key, preactComputed(() => fn()));\r\n            }\r\n            return {\r\n                ...acc,\r\n                [key]: () => computedSignals.get(key).value,\r\n            };\r\n        }\r\n\r\n        // \u0414\u043B\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0439 \u0441 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430\u043C\u0438 \u0441\u043E\u0437\u0434\u0430\u0451\u043C \u043A\u044D\u0448\r\n        return {\r\n            ...acc,\r\n            [key]: (...args: any[]) => {\r\n                const cacheKey = JSON.stringify(args); // \u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F \u043A\u043B\u044E\u0447\u0430 \u0434\u043B\u044F \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432\r\n                let argCache = computedCache.get(key);\r\n\r\n                if (!argCache) {\r\n                    argCache = new Map<string, any>();\r\n                    computedCache.set(key, argCache);\r\n                }\r\n\r\n                if (!argCache.has(cacheKey)) {\r\n                    const signal = preactComputed(() => fn(...args));\r\n                    argCache.set(cacheKey, signal);\r\n                }\r\n\r\n                return argCache.get(cacheKey).value;\r\n            },\r\n        };\r\n    }, {} as ComputedProperties<C>);\r\n\r\n    return computed;\r\n}\r\n", "// computed-utils.ts\r\n\r\nimport { ReadonlySignal, Signal, computed as preactComputed } from '@preact/signals-core';\r\n\r\ninterface ComputedCache<T> {\r\n    signal: Signal<T>;\r\n    args: unknown[];\r\n    lastAccessed: number;\r\n}\r\n\r\nexport class ComputedManager {\r\n    private static maxCacheSize = 1000;\r\n    private static cleanupThreshold = 0.8; // 80% of maxCacheSize\r\n    private static cacheTimeout = 5 * 60 * 1000; // 5 minutes\r\n\r\n    private static createCacheKey(args: unknown[]): string {\r\n        return args.map(arg => {\r\n            if (arg === null) return 'null';\r\n            if (arg === undefined) return 'undefined';\r\n            if (typeof arg === 'object') {\r\n                // Try to use id or similar unique identifier first\r\n                const obj = arg as Record<string, unknown>;\r\n                if ('id' in obj) return String(obj.id);\r\n                if ('key' in obj) return String(obj.key);\r\n                // Fall back to stable stringification for objects\r\n                return JSON.stringify(this.sortObjectKeys(obj));\r\n            }\r\n            return String(arg);\r\n        }).join('|');\r\n    }\r\n\r\n    private static sortObjectKeys<T extends object>(obj: T): T {\r\n        if (Array.isArray(obj)) {\r\n            return obj.map(item =>\r\n                typeof item === 'object' && item !== null ? this.sortObjectKeys(item) : item\r\n            ) as unknown as T;\r\n        }\r\n        return Object.keys(obj)\r\n            .sort()\r\n            .reduce((acc, key) => {\r\n                const value = obj[key as keyof T];\r\n                (acc as any)[key] = typeof value === 'object' && value !== null\r\n                    ? this.sortObjectKeys(value)\r\n                    : value;\r\n                return acc;\r\n            }, {} as T);\r\n    }\r\n\r\n    private static argsEqual(a: unknown[], b: unknown[]): boolean {\r\n        if (a.length !== b.length) return false;\r\n        return a.every((val, i) => {\r\n            if (Object.is(val, b[i])) return true;\r\n            if (typeof val === 'object' && val && typeof b[i] === 'object' && b[i]) {\r\n                return JSON.stringify(this.sortObjectKeys(val as object)) ===\r\n                    JSON.stringify(this.sortObjectKeys(b[i] as object));\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    public static createComputed<T, Args extends unknown[]>(\r\n        fn: (...args: Args) => T,\r\n        options: {\r\n            maxAge?: number;\r\n            cacheSize?: number;\r\n        } = {}\r\n    ): (...args: Args) => T {\r\n        const cache = new Map<string, ComputedCache<T>>();\r\n        const maxAge = options.maxAge ?? this.cacheTimeout;\r\n        const maxSize = options.cacheSize ?? this.maxCacheSize;\r\n\r\n        return (...args: Args): T => {\r\n            // For computed without arguments, we can just create a single signal\r\n            if (args.length === 0) {\r\n                if (!cache.has('_')) {\r\n                    const signal = preactComputed(() => fn(...args));\r\n                    cache.set('_', {\r\n                        signal,\r\n                        args: [],\r\n                        lastAccessed: Date.now()\r\n                    });\r\n                }\r\n                const cached = cache.get('_')!;\r\n                cached.lastAccessed = Date.now();\r\n                return cached.signal.value;\r\n            }\r\n\r\n            const cacheKey = this.createCacheKey(args);\r\n            const cached = cache.get(cacheKey);\r\n\r\n            // Check cache and args equality\r\n            if (cached && this.argsEqual(cached.args, args)) {\r\n                const now = Date.now();\r\n                if (now - cached.lastAccessed <= maxAge) {\r\n                    cached.lastAccessed = now;\r\n                    return cached.signal.value;\r\n                }\r\n            }\r\n\r\n            // Clean up cache if needed\r\n            if (cache.size >= maxSize * this.cleanupThreshold) {\r\n                this.cleanup(cache, maxAge);\r\n            }\r\n\r\n            // Create new computed\r\n            const signal = preactComputed(() => fn(...args));\r\n            cache.set(cacheKey, {\r\n                signal,\r\n                args: [...args],\r\n                lastAccessed: Date.now()\r\n            });\r\n\r\n            return signal.value;\r\n        };\r\n    }\r\n\r\n    private static cleanup<T>(\r\n        cache: Map<string, ComputedCache<T>>,\r\n        maxAge: number\r\n    ): void {\r\n        const now = Date.now();\r\n        for (const [key, value] of cache.entries()) {\r\n            if (now - value.lastAccessed > maxAge) {\r\n                cache.delete(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function createComputedProperty<T, Args extends unknown[]>(\r\n    fn: (...args: Args) => T,\r\n    options?: { maxAge?: number; cacheSize?: number }\r\n): (...args: Args) => T {\r\n    return ComputedManager.createComputed(fn, options);\r\n}\r\n\r\nexport type ComputedProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReadonlySignal<ReturnType<C[K]>>\r\n    : never;\r\n};\r\n\r\n// Helper type for inferring computed types\r\nexport type InferComputedType<T> = T extends (...args: any[]) => any\r\n    ? ReturnType<T>\r\n    : never;", "import { State, createState } from './state';\r\nimport { ComputedProperties, GettersProperties } from './component';\r\nimport { ComputedManager } from './untils';\r\n\r\ntype ComputedFn<S> = (context: {\r\n    state: State<S>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\ntype ActionsFn<S, C> = (context: {\r\n    state: State<S>;\r\n    computed: ComputedProperties<C>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\ntype GettersFn<S> = ComputedFn<S>;\r\n\r\nexport interface StoreOptions<S = any, G extends GettersFn<S> = any, C extends ComputedFn<S> = any, A extends ActionsFn<S, ReturnType<C>> = any> {\r\n    state: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n}\r\n\r\nexport interface StoreContext<S, G extends GettersFn<S>, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>> {\r\n    state: State<S>;\r\n    getters: GettersProperties<ReturnType<G>>;\r\n    computed: ComputedProperties<ReturnType<C>>;\r\n    actions: ReturnType<A>;\r\n}\r\n\r\nexport interface GlobalStore extends Record<string, StoreContext<any, any, any, any>> { }\r\n\r\nexport interface StoreRegistry {\r\n    list: Partial<GlobalStore>;\r\n    $: <K extends keyof GlobalStore, >(key: K) => GlobalStore[K];\r\n    register: <K extends keyof GlobalStore>(\r\n        key: K,\r\n        store: GlobalStore[K]\r\n    ) => void;\r\n}\r\n\r\nconst globalStore: Partial<GlobalStore> = {};\r\n\r\nexport function createStore<S, G extends GettersFn<S>, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>>(\r\n    options: StoreOptions<S, G, C, A>\r\n): StoreContext<S, G, C, A> {\r\n    const { state: initialState, getters: gettersFn, computed: computedFn, actions: actionsFn } = options;\r\n\r\n    const state = createState(initialState);\r\n\r\n    const getters = gettersFn\r\n        ? Object.entries(gettersFn({ state })).reduce((acc, [key, fn]) => ({\r\n            ...acc,\r\n            [key]: fn()\r\n        }), {}) as GettersProperties<ReturnType<G>>\r\n        : ({} as GettersProperties<ReturnType<G>>);\r\n\r\n    // \u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 computed\r\n    const computed = computedFn\r\n        ? Object.entries(computedFn({ state })).reduce((acc, [key, fn]) => {\r\n            const computedProperty = ComputedManager.createComputed(\r\n                () => fn(),\r\n                {\r\n                    maxAge: 15 * 60 * 1000, // 15 \u043C\u0438\u043D\u0443\u0442 \u0434\u043B\u044F store computed\r\n                    cacheSize: 500 // \u0431\u043E\u043B\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F store\r\n                }\r\n            );\r\n\r\n            return {\r\n                ...acc,\r\n                [key]: {\r\n                    get value() {\r\n                        return computedProperty();\r\n                    }\r\n                }\r\n            };\r\n        }, {}) as ComputedProperties<ReturnType<C>>\r\n        : ({} as ComputedProperties<ReturnType<C>>);\r\n\r\n    const actions = actionsFn\r\n        ? (actionsFn({\r\n            state,\r\n            computed\r\n        }) as ReturnType<A>)\r\n        : ({} as ReturnType<A>);\r\n\r\n    return { state, getters, computed, actions };\r\n}\r\n\r\nfunction registerStore<K extends keyof GlobalStore>(\r\n    key: K,\r\n    store: GlobalStore[K]\r\n): void {\r\n    if (globalStore[key]) {\r\n        throw new Error(`Store \"${key}\" already exists`);\r\n    }\r\n    globalStore[key] = store;\r\n\r\n}\r\n\r\nfunction getStore<K extends keyof GlobalStore>(key: K): GlobalStore[K] {\r\n    const store = globalStore[key];\r\n    if (!store) {\r\n        throw new Error(`Store \"${key}\" not found`);\r\n    }\r\n    return store;\r\n}\r\n\r\nexport function defineStore<\r\n    S extends object,\r\n    G extends GettersFn<S>,\r\n    C extends Record<string, (...args: any[]) => any>,\r\n    A extends ActionsFn<S, C>\r\n>(options: {\r\n    key: keyof GlobalStore;\r\n    state: S;\r\n    getters?: G;\r\n    computed?: (context: { state: State<S> }) => C;\r\n    actions?: A;\r\n}) {\r\n    const { key, state, ...rest } = options;\r\n    const store = createStore({ state: state, ...rest });\r\n    storeRegistry.register(key, store);\r\n    return store;\r\n}\r\n\r\nexport const storeRegistry: StoreRegistry = {\r\n    list: globalStore,\r\n    $: getStore,\r\n    register: registerStore,\r\n};", "import { reactive } from 'uhtml/reactive';\r\nimport { effect, ReadonlySignal, Signal, signal, computed as preactComputed } from '@preact/signals-core';\r\nimport { State, createState } from './state';\r\nimport { StoreRegistry, storeRegistry } from './store';\r\nimport { ComputedManager } from './untils';\r\n\r\ntype ConstructorToType<T> =\r\n    T extends StringConstructor ? string :\r\n    T extends NumberConstructor ? number :\r\n    T extends BooleanConstructor ? boolean :\r\n    T extends ArrayConstructor ? T[] :\r\n    T extends ObjectConstructor ? Record<string, unknown> :\r\n    T;\r\n\r\ntype ModelPropDefinition<T> = {\r\n    type: TypeConstructor;\r\n    default?: T;\r\n    model?: { __type: T };\r\n};\r\n\r\ntype SimplePropDefinition<T extends TypeConstructor> = {\r\n    type: T;\r\n    default?: ConstructorToType<T>;\r\n};\r\n\r\ntype PropDefinition<T = unknown> =\r\n    T extends TypeConstructor\r\n    ? SimplePropDefinition<T>\r\n    : ModelPropDefinition<T>;\r\n\r\ntype InferPropType<T> =\r\n    T extends SimplePropDefinition<infer U>\r\n    ? ConstructorToType<U>\r\n    : T extends ModelPropDefinition<infer M>\r\n    ? M\r\n    : never;\r\n\r\ntype InferProps<T extends Record<string, PropDefinition>> = {\r\n    [K in keyof T]: InferPropType<T[K]>;\r\n};\r\n\r\nexport type ComputedProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReturnType<C[K]>\r\n    : never;\r\n};\r\n\r\nexport type GettersProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReturnType<C[K]>\r\n    : never;\r\n};\r\n\r\ntype TypeConstructor =\r\n    | StringConstructor\r\n    | NumberConstructor\r\n    | BooleanConstructor\r\n    | ObjectConstructor\r\n    | ArrayConstructor;\r\n\r\ntype BaseContext<P, S> = {\r\n    props: P;\r\n    el: CustomHtmlElement;\r\n    slots: Record<string, Node[]>,\r\n    state: State<S>;\r\n    store: StoreRegistry;\r\n};\r\n\r\ntype GettersFn<P, S> = (context: BaseContext<P, S>) => Record<string, () => any>;\r\ntype ComputedFn<P, S> = (context: BaseContext<P, S>) => Record<string, () => any>;\r\ntype ActionsFn<P, S, C> = (context: BaseContext<P, S> & {\r\n    computed: ComputedProperties<C>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\nexport interface ComponentContext<\r\n    P,\r\n    S,\r\n    G extends GettersFn<P, S>,\r\n    C extends ComputedFn<P, S>,\r\n    A extends ActionsFn<P, S, ReturnType<C>>\r\n> {\r\n    props: P;\r\n    state: State<S>;\r\n    getters: GettersProperties<ReturnType<G>>;\r\n    computed: ComputedProperties<ReturnType<C>>;\r\n    actions: ReturnType<A>;\r\n    el: CustomHtmlElement;\r\n    slots: Record<string, Node[]>;\r\n    store: StoreRegistry;\r\n}\r\n\r\nexport interface CustomHtmlElement extends HTMLElement {\r\n    $<T = any>(key: string): T | undefined;\r\n    emitEvent<T = any>(name: string, detail?: T): void;\r\n}\r\n\r\nexport interface ComponentOptions2<\r\n    P extends Record<string, PropDefinition> = any,\r\n    S = any,\r\n    G extends GettersFn<InferProps<P>, S> = any,\r\n    C extends ComputedFn<InferProps<P>, S> = any,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>> = any\r\n> {\r\n    tagName: string;\r\n    props?: P;\r\n    state?: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n    connected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n    render?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => unknown;\r\n    listen?: (params: ComponentContext<InferProps<P>, S, G, C, A> & {\r\n        newValue: S;\r\n        oldValue: S;\r\n    }) => void;\r\n    disconnected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n}\r\n\r\n\r\n\r\ntype ComponentOptions<\r\n    P extends Record<string, PropDefinition>,\r\n    S,\r\n    G extends GettersFn<InferProps<P>, S>,\r\n    C extends ComputedFn<InferProps<P>, S>,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>>\r\n> = {\r\n    tagName: string;\r\n    props?: P;\r\n    state?: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n    connected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n    render?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => unknown;\r\n    listen?: (params: ComponentContext<InferProps<P>, S, G, C, A> & {\r\n        newValue: S;\r\n        oldValue: S;\r\n    }) => void;\r\n    disconnected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n};\r\n\r\n\r\nexport function defineComponent<\r\n    P extends Record<string, PropDefinition>,\r\n    S,\r\n    G extends GettersFn<InferProps<P>, S>,\r\n    C extends ComputedFn<InferProps<P>, S>,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>>\r\n>(options: ComponentOptions<P, S, G, C, A>) {\r\n    const {\r\n        tagName,\r\n        props: propsDefinition = {} as P,\r\n        state: initialState,\r\n        getters: gettersFn = (() => ({})) as GettersFn<InferProps<P>, S>,\r\n        computed: computedFn = (() => ({})) as ComputedFn<InferProps<P>, S>,\r\n        actions: actionsFn = (() => ({})) as ActionsFn<InferProps<P>, S, ReturnType<ComputedFn<InferProps<P>, S>>>,\r\n        connected,\r\n        disconnected,\r\n        render,\r\n        listen\r\n    } = options;\r\n\r\n    const uRender = reactive(effect);\r\n\r\n    class CustomElement extends HTMLElement implements CustomHtmlElement {\r\n        props: Signal<InferProps<P>>;\r\n        state: State<S>;\r\n        getters: GettersProperties<ReturnType<G>>;\r\n        computed: ComputedProperties<ReturnType<C>>;\r\n        actions: ReturnType<A>;\r\n        slots: Record<string, Node[]> = {};\r\n        cleanup: (() => void)[] = [];\r\n\r\n        static get observedAttributes() {\r\n            return Object.keys(propsDefinition).map((name) => `data-${name}`);\r\n        }\r\n\r\n        constructor() {\r\n            super();\r\n            this.props = signal({} as InferProps<P>);\r\n            this.props.value = this.initializeProps();\r\n            this.state = createState(initialState as S);\r\n            this.getters = this.setupGetters();\r\n            this.computed = this.setupComputed();\r\n            this.actions = this.setupActions();\r\n        }\r\n\r\n        public $<T = any>(key: string) {\r\n            return (this as any)[key] as T | undefined;\r\n        }\r\n\r\n        public emitEvent<T = any>(name: string, detail: T = {} as T): void {\r\n            this.dispatchEvent(new CustomEvent(name, { detail }));\r\n        }\r\n\r\n        setupGetters(): GettersProperties<ReturnType<G>> {\r\n            const getterObj = gettersFn({\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            });\r\n\r\n            return Object.entries(getterObj).reduce((acc, [key, fn]) => ({\r\n                ...acc,\r\n                [key]: fn()\r\n            }), {}) as GettersProperties<ReturnType<G>>;\r\n        }\r\n\r\n        setupComputed(): ComputedProperties<ReturnType<C>> {\r\n            const context = {\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            };\r\n\r\n            const computedObj = computedFn(context);\r\n            const computed = {} as ComputedProperties<ReturnType<C>>;\r\n\r\n            // \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C ComputedManager \u0434\u043B\u044F \u043A\u0430\u0436\u0434\u043E\u0433\u043E computed \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\r\n            for (const [key, fn] of Object.entries(computedObj)) {\r\n                const computedProperty = ComputedManager.createComputed(\r\n                    () => fn(),\r\n                    {\r\n                        maxAge: 5 * 60 * 1000, // 5 \u043C\u0438\u043D\u0443\u0442 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432\r\n                        cacheSize: 100 // \u043C\u0435\u043D\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432\r\n                    }\r\n                );\r\n\r\n                Object.defineProperty(computed, key, {\r\n                    get: () => computedProperty(),\r\n                    enumerable: true\r\n                });\r\n            }\r\n\r\n            return computed;\r\n        }\r\n\r\n        setupActions(): ReturnType<A> {\r\n            return actionsFn({\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                computed: this.computed,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            }) as ReturnType<A>;\r\n        }\r\n\r\n        get context(): ComponentContext<InferProps<P>, S, G, C, A> {\r\n            return {\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                getters: this.getters,\r\n                computed: this.computed,\r\n                actions: this.actions,\r\n                el: this,\r\n                slots: this.slots,\r\n                store: storeRegistry,\r\n            };\r\n        }\r\n\r\n        initializeProps(): InferProps<P> {\r\n            const props = {} as InferProps<P>;\r\n            for (const [key, definition] of Object.entries(propsDefinition)) {\r\n                const attrName = `data-${key}`;\r\n                const attrValue = this.getAttribute(attrName);\r\n                const defaultValue = definition.default ?? this.getDefaultForType(definition.type);\r\n                props[key as keyof P] = attrValue !== null\r\n                    ? this.parseAttributeValue(attrValue, definition.type)\r\n                    : defaultValue;\r\n            }\r\n            return props;\r\n        }\r\n\r\n        getDefaultForType(type: PropDefinition['type']): any {\r\n            switch (type) {\r\n                case String: return '';\r\n                case Number: return 0;\r\n                case Boolean: return false;\r\n                case Object: return {};\r\n                case Array: return [];\r\n                default: return null;\r\n            }\r\n        }\r\n\r\n        parseAttributeValue(value: string, type: PropDefinition['type']): any {\r\n            switch (type) {\r\n                case Number:\r\n                    return Number(value);\r\n                case Boolean:\r\n                    return value !== null && value !== 'false';\r\n                case Object:\r\n                case Array:\r\n                    try {\r\n                        return JSON.parse(value);\r\n                    } catch {\r\n                        return type === Object ? {} : [];\r\n                    }\r\n                default:\r\n                    return value;\r\n            }\r\n        }\r\n\r\n        attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n            const propName = name.replace(/^data-/, '');\r\n            const propDef = (propsDefinition as any)[propName];\r\n            if (!propDef) return;\r\n            const value = this.parseAttributeValue(newValue, propDef.type);\r\n            this.updateProp(propName as keyof P, value);\r\n        }\r\n\r\n        updateProp(name: keyof P, value: any) {\r\n            this.props.value = {\r\n                ...this.props.peek(),\r\n                [name]: value,\r\n            };\r\n        }\r\n\r\n        getPropValue() {\r\n            return this.props.value;\r\n        }\r\n\r\n        setupListener() {\r\n            if (!listen) return;\r\n\r\n            let previousValue = this.state.peek();\r\n            const cleanup = effect(() => {\r\n                const currentValue = this.state.value;\r\n                listen({\r\n                    ...this.context,\r\n                    newValue: currentValue,\r\n                    oldValue: previousValue\r\n                });\r\n                previousValue = currentValue;\r\n            });\r\n\r\n            this.cleanup.push(cleanup);\r\n        }\r\n\r\n        setupRender() {\r\n            if (!render) return;\r\n\r\n            const cleanup = uRender(this, () => render(this.context));\r\n            this.cleanup.push(cleanup);\r\n        }\r\n\r\n        collectSlots() {\r\n            const slots: Record<string, Node[]> = { default: [] };\r\n            Array.from(this.childNodes).forEach(node => {\r\n                if (node instanceof Element) {\r\n                    const slotName = node.getAttribute('data-slot') || 'default';\r\n                    slots[slotName] = slots[slotName] || [];\r\n                    slots[slotName].push(node);\r\n                } else if (node.textContent?.trim()) {\r\n                    slots.default.push(node);\r\n                }\r\n            });\r\n            this.slots = slots;\r\n        }\r\n\r\n        connectedCallback() {\r\n            requestAnimationFrame(() => {\r\n                this.collectSlots();\r\n                this.setupListener();\r\n                this.setupRender();\r\n                connected?.(this.context);\r\n            })\r\n        }\r\n\r\n        disconnectedCallback() {\r\n            this.cleanup.forEach(cleanup => cleanup());\r\n            this.cleanup = [];\r\n            disconnected?.(this.context);\r\n        }\r\n    }\r\n    if (tagName) {\r\n        customElements.define(tagName, CustomElement);\r\n    }\r\n}", "export class StyleRegistry {\r\n    private static instance: StyleRegistry;\r\n    private styles: Map<string, string> = new Map();\r\n    private componentInstances: Map<string, Set<HTMLElement>> = new Map();\r\n    private styleElements: Map<string, HTMLStyleElement> = new Map();\r\n\r\n    private constructor() { }\r\n\r\n    static getInstance(): StyleRegistry {\r\n        if (!StyleRegistry.instance) {\r\n            StyleRegistry.instance = new StyleRegistry();\r\n        }\r\n        return StyleRegistry.instance;\r\n    }\r\n\r\n    register(componentName: string, css: string): void {\r\n        if (!this.styles.has(componentName)) {\r\n            this.styles.set(componentName, css);\r\n        }\r\n    }\r\n\r\n    connectComponent(componentName: string, element: HTMLElement): void {\r\n        if (!this.componentInstances.has(componentName)) {\r\n            this.componentInstances.set(componentName, new Set());\r\n        }\r\n\r\n        const instances = this.componentInstances.get(componentName)!;\r\n        instances.add(element);\r\n\r\n        // \u0415\u0441\u043B\u0438 \u044D\u0442\u043E \u043F\u0435\u0440\u0432\u044B\u0439 \u044D\u043A\u0437\u0435\u043C\u043F\u043B\u044F\u0440 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430, \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u043C \u0441\u0442\u0438\u043B\u0438\r\n        if (instances.size === 1) {\r\n            this.injectStyles(componentName);\r\n        }\r\n    }\r\n\r\n    disconnectComponent(componentName: string, element: HTMLElement): void {\r\n        const instances = this.componentInstances.get(componentName);\r\n        if (!instances) return;\r\n\r\n        instances.delete(element);\r\n\r\n        // \u0415\u0441\u043B\u0438 \u0431\u043E\u043B\u044C\u0448\u0435 \u043D\u0435\u0442 \u044D\u043A\u0437\u0435\u043C\u043F\u043B\u044F\u0440\u043E\u0432 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430, \u0443\u0434\u0430\u043B\u044F\u0435\u043C \u0441\u0442\u0438\u043B\u0438\r\n        if (instances.size === 0) {\r\n            this.removeStyles(componentName);\r\n        }\r\n    }\r\n\r\n    private injectStyles(componentName: string): void {\r\n        const css = this.styles.get(componentName);\r\n        if (!css) return;\r\n\r\n        const styleElement = document.createElement('style');\r\n        styleElement.setAttribute('data-component', componentName);\r\n        styleElement.textContent = css;\r\n        document.head.appendChild(styleElement);\r\n        this.styleElements.set(componentName, styleElement);\r\n    }\r\n\r\n    private removeStyles(componentName: string): void {\r\n        const styleElement = this.styleElements.get(componentName);\r\n        if (styleElement && document.head.contains(styleElement)) {\r\n            document.head.removeChild(styleElement);\r\n            this.styleElements.delete(componentName);\r\n        }\r\n    }\r\n}\r\n", "import { StyleRegistry } from \"./styles-registry\";\r\n\r\nexport interface ThemeConfig {\r\n    [key: string]: string | number | ThemeConfig;\r\n}\r\n\r\nexport function createComponentStyles(componentName: string, cssTemplate: string, defaultConfig: ThemeConfig = {}) {\r\n    const prefix = `--${componentName}`;\r\n\r\n    function configToCssVars(config: ThemeConfig, parentKey: string = ''): string {\r\n        return Object.entries(config).map(([key, value]) => {\r\n            const fullKey = parentKey ? `${parentKey}-${key}` : `${prefix}-${key}`;\r\n            if (typeof value === 'object') {\r\n                return configToCssVars(value as ThemeConfig, fullKey);\r\n            }\r\n            return `${fullKey}: ${value};`;\r\n        }).join('\\n');\r\n    }\r\n\r\n    const defaultVars = configToCssVars(defaultConfig);\r\n    const componentStyles = `\r\n        :root {\r\n            ${defaultVars}\r\n        }\r\n        ${cssTemplate}\r\n    `;\r\n\r\n    StyleRegistry.getInstance().register(componentName, componentStyles);\r\n\r\n    return {\r\n        connectComponent(element: HTMLElement) {\r\n            StyleRegistry.getInstance().connectComponent(componentName, element);\r\n        },\r\n        disconnectComponent(element: HTMLElement) {\r\n            StyleRegistry.getInstance().disconnectComponent(componentName, element);\r\n        },\r\n        updateConfig(config: Partial<ThemeConfig>): void {\r\n            const style = document.createElement('style');\r\n            style.textContent = `\r\n                :root {\r\n                    ${configToCssVars(config as any)}\r\n                }\r\n            `;\r\n            document.head.appendChild(style);\r\n        }\r\n    };\r\n}", "import { createComponentStyles } from \"signa/core/component-styles\";\r\n\r\n\r\nexport default createComponentStyles('signa-button', `\r\n    :host {\r\n        display: inline-block;\r\n    }\r\n    \r\n    .signa-button {\r\n        background: var(--signa-button-background, #007bff);\r\n        color: var(--signa-button-color, #ffffff);\r\n        padding: var(--signa-button-padding, 8px 16px);\r\n        border-radius: var(--signa-button-radius, 4px);\r\n        border: var(--signa-button-border, none);\r\n        cursor: pointer;\r\n    }\r\n\r\n    .signa-button:hover {\r\n        background: var(--signa-button-hover-background, #0056b3);\r\n    }\r\n\r\n    /* Variants */\r\n    :host([variant=\"secondary\"]) .signa-button {\r\n        background: var(--signa-button-secondary-background, #6c757d);\r\n    }\r\n\r\n    :host([variant=\"outline\"]) .signa-button {\r\n        background: transparent;\r\n        border: 1px solid var(--signa-button-background, #007bff);\r\n        color: var(--signa-button-background, #007bff);\r\n    }\r\n`);\r\n", "\r\nimport { defineStore, defineComponent, html, State, createState } from \"signa/core\";\r\nimport styles from './styles';\r\n\r\nconst counterStore = defineStore({\r\n    key: 'counter',\r\n    state: { count: 0 },\r\n    computed: () => ({\r\n        double: () => true,\r\n    })\r\n})\r\n\r\n// example def types\r\ndeclare module \"signa/core\" {\r\n    interface GlobalStore {\r\n        counter: typeof counterStore\r\n    }\r\n}\r\n\r\ndefineComponent({\r\n    tagName: 'my-counter',\r\n    state: { count: 0 },\r\n    props: {\r\n        val: {\r\n            type: Number,\r\n            default: 20,\r\n        }\r\n    },\r\n    listen(params) {\r\n\r\n    },\r\n    connected(ctx) {\r\n        styles.connectComponent(ctx.el);\r\n    },\r\n    disconnected(ctx) {\r\n        styles.disconnectComponent(ctx.el);\r\n    },\r\n    getters: (context) => ({\r\n        counterStore: () => {\r\n            return context.store.$('counter')\r\n        },\r\n        hi: () => 'hi',\r\n    }),\r\n    computed: ({ state, props }) => {\r\n        console.log(props)\r\n        return ({\r\n            doubleCount: () => state.value.count + props.val,\r\n            isEven: () => state.value.count % 2 === 0,\r\n        });\r\n    },\r\n    actions: ({ state }) => ({\r\n        increment: (amount: number) => {\r\n            state.emit({ count: state.value.count + amount });\r\n        },\r\n        reset: () => {\r\n            state.emit({ count: 0 });\r\n        }\r\n    }),\r\n\r\n    render: (context) => {\r\n        const { state, computed, actions, getters: { counterStore } } = context;\r\n\r\n        return html`\r\n        <div>\r\n            <p>Count test: ${state.value.count}</p>\r\n            <p>Double: ${computed.doubleCount}</p>\r\n            <p>Is Even: ${computed.isEven}</p>\r\n            <button onclick=${() => actions.increment(1)}>+1</button>\r\n            <button onclick=${actions.reset}>Reset</button>\r\n        </div>\r\n    `;\r\n    },\r\n});\r\n\r\ndefineComponent({\r\n    tagName: 'my-counter-2',\r\n    state: { count: 0 },\r\n    props: {\r\n        count: {\r\n            type: Number,\r\n            default: 0\r\n        }\r\n    },\r\n    getters: (context) => ({\r\n        hi: () => 'hi',\r\n        counterStore: () => context.store.$('counter'),\r\n    }),\r\n    computed: ({ state }) => ({\r\n        doubleCount: () => state.value.count * 2,\r\n        isEven: () => state.value.count % 2 === 0,\r\n    }),\r\n    actions: ({ state }) => ({\r\n        increment: (amount: number) => {\r\n            state.emit({ count: state.value.count + amount });\r\n        },\r\n        reset: () => {\r\n            state.emit({ count: 0 });\r\n        }\r\n    }),\r\n    listen(params) {\r\n\r\n    },\r\n    render: ({ props, state, computed, actions, getters: { counterStore, hi } }) => {\r\n        return html`\r\n        <div>\r\n            counter 2 component props value ${props.count}\r\n            <p>Count: ${state.value.count}</p>\r\n            <p>Double: ${computed.doubleCount}</p>\r\n            <p>Is Even: ${computed.isEven}</p>\r\n            <button onclick=${() => actions.increment(1)}>+1</button>\r\n            <button onclick=${actions.reset}>Reset</button>\r\n            <my-component  data-count=\"${state.value.count}\"></my-component>\r\n        </div>\r\n    `;\r\n    },\r\n});\r\n\r\ndefineComponent({\r\n    tagName: 'my-component',\r\n    state: { count: 0 },\r\n    props: {\r\n        count: {\r\n            type: Number,\r\n            default: 0\r\n        }\r\n    },\r\n    getters: (context) => ({\r\n        hi: () => 'hi',\r\n        counterStore: () => context.store.$('counter'),\r\n    }),\r\n    computed: ({ state }) => ({\r\n        doubleCount: () => state.value.count * 2,\r\n        isEven: () => state.value.count % 2 === 0,\r\n    }),\r\n    actions: ({ state }) => ({\r\n        increment: (amount: number) => {\r\n            state.emit({ count: state.value.count + amount });\r\n        },\r\n        reset: () => {\r\n            state.emit({ count: 0 });\r\n        }\r\n    }),\r\n    listen(params) {\r\n\r\n    },\r\n    render: ({ props, state, computed, actions, getters: { counterStore } }) => {\r\n        return html`\r\n        <div>\r\n            <div>props: ${props.count}</div>\r\n            <p >Count: ${state.value.count}</p>\r\n            <p>Double: ${computed.doubleCount}</p>\r\n            <p>Is Even: ${computed.isEven}</p>\r\n            <button onclick=${() => actions.increment(1)}>+1</button>\r\n            <button onclick=${actions.reset}>Reset</button>\r\n         \r\n        </div>\r\n    `;\r\n    },\r\n});\r\n\r\nconst counterStateValue = { count: 0 };\r\nconst useActions = (state: State<typeof counterStateValue>) => ({\r\n    inc: () => state.emit({ count: state.value.count + 1 })\r\n})\r\n\r\n\r\n// owner + external composition state actions ...\r\ndefineComponent({\r\n    tagName: 'parent-example-cmp-2',\r\n    state: { example: 0, ...counterStateValue }, // owner local state + external\r\n    actions: ({ state }) => ({\r\n        ...useActions(state),\r\n        myinc: () => { state.emit({ example: state.value.example + 1 }) }\r\n    }),\r\n    render(context) {\r\n        return html`${context.state.value.example}<example-cmp @button-click=\"${() => console.log('button-click event')}\"></example-cmp>`\r\n    },\r\n})\r\n\r\ndefineComponent({\r\n    tagName: 'example-cmp',\r\n    render(context) {\r\n        return html`<button @click=\"${() => context.el.emitEvent('button-click')}\">Click</button>`\r\n    },\r\n})\r\n\r\n\r\nconst exState = createState(0);\r\nconst inc = exState.value + 1;\r\n\r\n\r\ndefineComponent({\r\n    tagName: 'example-cmp-2',\r\n    render(context) {\r\n        return html`<button @click=\"${() => context.el.emitEvent('button-click')}\">Click</button>`\r\n    },\r\n})\r\n\r\nexport interface ButtonProps {\r\n    variant: 'primary' | 'secondary' | 'outline';\r\n}\r\n\r\nexport const Button = defineComponent({\r\n    tagName: 'signa-button',\r\n    props: {\r\n        variant: { type: String, default: 'primary' }\r\n    } as const,\r\n    render: ({ slots }) => {\r\n        console.log(slots.default)\r\n        return html`\r\n        <button class=\"signa-button\">\r\n            ${slots.default}\r\n        </button>\r\n    `;\r\n    }\r\n});\r\n"],
  "mappings": "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",
  "names": ["a", "b", "i", "ref", "i", "known", "detail", "hole", "ref", "svg", "a", "b", "c", "u", "t", "template", "direct", "i", "esm_default", "template", "prefix", "i", "_", "hole", "range", "text", "template", "esm_default", "i", "cache", "s", "t", "v", "b", "c", "i", "detail", "svg", "template", "svg", "template", "b", "hole", "svg", "ref", "tag", "template", "remove", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_flags", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "BRAND_SYMBOL", "_refresh", "_unsubscribe", "prev", "next", "subscribe", "fn", "_this", "effect", "prevContext", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "call", "undefined", "_fn", "_globalVersion", "OUTDATED", "err", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "_nextBatchedEffect", "_callback", "finish", "_start", "bind", "_dispose", "a", "b", "i", "cache", "signal", "cached", "detail", "prefix", "style", "counterStore"]
}
