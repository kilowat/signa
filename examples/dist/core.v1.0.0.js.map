{
  "version": 3,
  "sources": ["../../src/core/index.ts", "../../node_modules/udomdiff/esm/index.js", "../../node_modules/uhtml/esm/utils.js", "../../node_modules/custom-function/esm/factory.js", "../../node_modules/uhtml/esm/range.js", "../../node_modules/uhtml/esm/persistent-fragment.js", "../../node_modules/uhtml/esm/handler.js", "../../node_modules/uhtml/esm/literals.js", "../../node_modules/uhtml/esm/creator.js", "../../node_modules/domconstants/esm/re.js", "../../node_modules/@webreflection/uparser/esm/index.js", "../../node_modules/uhtml/esm/create-content.js", "../../node_modules/uhtml/esm/parser.js", "../../node_modules/uhtml/esm/rabbit.js", "../../node_modules/uhtml/esm/index.js", "../../node_modules/uhtml/esm/render/shared.js", "../../node_modules/uhtml/esm/keyed.js", "../../node_modules/gc-hook/esm/index.js", "../../node_modules/uhtml/esm/render/reactive.js", "../../node_modules/@preact/signals-core/src/index.ts", "../../src/core/state.ts", "../../src/core/untils.ts", "../../src/core/store.ts", "../../src/core/component.ts"],
  "sourcesContent": ["export * from './component'\r\nexport * from './state'\r\nexport * from './store'\r\nexport { html, htmlFor } from 'uhtml/reactive'\r\nexport { computed as preactComputed, effect } from '@preact/signals-core';", "/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -0).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -0).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "const { isArray } = Array;\nconst { getPrototypeOf, getOwnPropertyDescriptor } = Object;\n\nexport { isArray };\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const empty = [];\n\nexport const newRange = () => document.createRange();\n\n/**\n * Set the `key` `value` pair to the *Map* or *WeakMap* and returns the `value`\n * @template T\n * @param {Map | WeakMap} map\n * @param {any} key\n * @param {T} value\n * @returns {T}\n */\nexport const set = (map, key, value) => {\n  map.set(key, value);\n  return value;\n};\n\n/**\n * Return a descriptor, if any, for the referenced *Element*\n * @param {Element} ref\n * @param {string} prop\n * @returns \n */\nexport const gPD = (ref, prop) => {\n  let desc;\n  do { desc = getOwnPropertyDescriptor(ref, prop); }\n  while(!desc && (ref = getPrototypeOf(ref)));\n  return desc;\n};\n\n/* c8 ignore start */\n/**\n * @param {DocumentFragment} content\n * @param {number[]} path\n * @returns {Element}\n */\nexport const find = (content, path) => path.reduceRight(childNodesIndex, content);\nconst childNodesIndex = (node, i) => node.childNodes[i];\n/* c8 ignore stop */\n", "const {setPrototypeOf} = Object;\n\n/**\n * @param {Function} Class any base class to extend without passing through it via super() call.\n * @returns {Function} an extensible class for the passed one.\n * @example\n *  // creating this very same module utility\n *  import custom from 'custom-function/factory';\n *  const CustomFunction = custom(Function);\n *  class MyFunction extends CustomFunction {}\n *  const mf = new MyFunction(() => {});\n */\nexport default Class => {\n  function Custom(target) {\n    return setPrototypeOf(target, new.target.prototype);\n  }\n  Custom.prototype = Class.prototype;\n  return Custom;\n};\n", "import { newRange } from './utils.js';\n\nlet range;\n/**\n * @param {Node | Element} firstChild\n * @param {Node | Element} lastChild\n * @param {boolean} preserve\n * @returns\n */\nexport default (firstChild, lastChild, preserve) => {\n  if (!range) range = newRange();\n  /* c8 ignore start */\n  if (preserve)\n    range.setStartAfter(firstChild);\n  else\n    range.setStartBefore(firstChild);\n  /* c8 ignore stop */\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n", "import { DOCUMENT_FRAGMENT_NODE } from 'domconstants/constants';\nimport custom from 'custom-function/factory';\nimport drop from './range.js';\nimport { empty } from './utils.js';\n\n/**\n * @param {PersistentFragment} fragment\n * @returns {Node | Element}\n */\nconst remove = ({firstChild, lastChild}, preserve) => drop(firstChild, lastChild, preserve);\n\nlet checkType = false;\n\n/**\n * @param {Node} node\n * @param {1 | 0 | -0 | -1} operation\n * @returns {Node}\n */\nexport const diffFragment = (node, operation) => (\n  checkType && node.nodeType === DOCUMENT_FRAGMENT_NODE ?\n    ((1 / operation) < 0 ?\n      (operation ? remove(node, true) : node.lastChild) :\n      (operation ? node.valueOf() : node.firstChild)) :\n    node\n);\n\nconst comment = value => document.createComment(value);\n\n/** @extends {DocumentFragment} */\nexport class PersistentFragment extends custom(DocumentFragment) {\n  #firstChild = comment('<>');\n  #lastChild = comment('</>');\n  #nodes = empty;\n  constructor(fragment) {\n    super(fragment);\n    this.replaceChildren(...[\n      this.#firstChild,\n      ...fragment.childNodes,\n      this.#lastChild,\n    ]);\n    checkType = true;\n  }\n  get firstChild() { return this.#firstChild; }\n  get lastChild() { return this.#lastChild; }\n  get parentNode() { return this.#firstChild.parentNode; }\n  remove() {\n    remove(this, false);\n  }\n  replaceWith(node) {\n    remove(this, true).replaceWith(node);\n  }\n  valueOf() {\n    const { parentNode } = this;\n    if (parentNode === this) {\n      if (this.#nodes === empty)\n        this.#nodes = [...this.childNodes];\n    }\n    else {\n      /* c8 ignore start */\n      // there are cases where a fragment might be just appended\n      // out of the box without valueOf() invoke (first render).\n      // When these are moved around and lose their parent and,\n      // such parent is not the fragment itself, it's possible there\n      // where changes or mutations in there to take care about.\n      // This is a render-only specific issue but it's tested and\n      // it's worth fixing to me to have more consistent fragments.\n      if (parentNode) {\n        let { firstChild, lastChild } = this;\n        this.#nodes = [firstChild];\n        while (firstChild !== lastChild)\n          this.#nodes.push((firstChild = firstChild.nextSibling));\n      }\n      /* c8 ignore stop */\n      this.replaceChildren(...this.#nodes);\n    }\n    return this;\n  }\n}\n", "import udomdiff from 'udomdiff';\nimport { empty, gPD, isArray, set } from './utils.js';\nimport { diffFragment } from './persistent-fragment.js';\nimport drop from './range.js';\n\nconst setAttribute = (element, name, value) =>\n  element.setAttribute(name, value);\n\n/**\n * @param {Element} element\n * @param {string} name\n * @returns {void}\n */\nexport const removeAttribute = (element, name) =>\n  element.removeAttribute(name);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const aria = (element, value) => {\n  for (const key in value) {\n    const $ = value[key];\n    const name = key === 'role' ? key : `aria-${key}`;\n    if ($ == null) removeAttribute(element, name);\n    else setAttribute(element, name, $);\n  }\n  return value;\n};\n\nlet listeners;\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const at = (element, value, name) => {\n  name = name.slice(1);\n  if (!listeners) listeners = new WeakMap;\n  const known = listeners.get(element) || set(listeners, element, {});\n  let current = known[name];\n  if (current && current[0]) element.removeEventListener(name, ...current);\n  current = isArray(value) ? value : [value, false];\n  known[name] = current;\n  if (current[0]) element.addEventListener(name, ...current);\n  return value;\n};\n\n/** @type {WeakMap<Node, Element | import(\"./persistent-fragment.js\").PersistentFragment>} */\nconst holes = new WeakMap;\n\n/**\n * @template T\n * @param {import(\"./literals.js\").Detail} detail\n * @param {T} value\n * @returns {T}\n */\nexport const hole = (detail, value) => {\n  const { t: node, n: hole } = detail;\n  let nullish = false;\n  switch (typeof value) {\n    case 'object':\n      if (value !== null) {\n        (hole || node).replaceWith((detail.n = value.valueOf()));\n        break;\n      }\n    case 'undefined':\n      nullish = true;\n    default:\n      node.data = nullish ? '' : value;\n      if (hole) {\n        detail.n = null;\n        hole.replaceWith(node);\n      }\n      break;\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const className = (element, value) => maybeDirect(\n  element, value, value == null ? 'class' : 'className'\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const data = (element, value) => {\n  const { dataset } = element;\n  for (const key in value) {\n    if (value[key] == null) delete dataset[key];\n    else dataset[key] = value[key];\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element | CSSStyleDeclaration} ref\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const direct = (ref, value, name) => (ref[name] = value);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const dot = (element, value, name) => direct(element, value, name.slice(1));\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const maybeDirect = (element, value, name) => (\n  value == null ?\n    (removeAttribute(element, name), value) :\n    direct(element, value, name)\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const ref = (element, value) => (\n  (typeof value === 'function' ?\n    value(element) : (value.current = element)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nconst regular = (element, value, name) => (\n  (value == null ?\n    removeAttribute(element, name) :\n    setAttribute(element, name, value)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const style = (element, value) => (\n  value == null ?\n    maybeDirect(element, value, 'style') :\n    direct(element.style, value, 'cssText')\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const toggle = (element, value, name) => (\n  element.toggleAttribute(name.slice(1), value),\n  value\n);\n\n/**\n * @param {Node} node\n * @param {Node[]} value\n * @param {string} _\n * @param {Node[]} prev\n * @returns {Node[]}\n */\nexport const array = (node, value, prev) => {\n  // normal diff\n  const { length } = value;\n  node.data = `[${length}]`;\n  if (length)\n    return udomdiff(node.parentNode, prev, value, diffFragment, node);\n  /* c8 ignore start */\n  switch (prev.length) {\n    case 1:\n      prev[0].remove();\n    case 0:\n      break;\n    default:\n      drop(\n        diffFragment(prev[0], 0),\n        diffFragment(prev.at(-1), -0),\n        false\n      );\n      break;\n  }\n  /* c8 ignore stop */\n  return empty;\n};\n\nexport const attr = new Map([\n  ['aria', aria],\n  ['class', className],\n  ['data', data],\n  ['ref', ref],\n  ['style', style],\n]);\n\n/**\n * @param {HTMLElement | SVGElement} element\n * @param {string} name\n * @param {boolean} svg\n * @returns\n */\nexport const attribute = (element, name, svg) => {\n  switch (name[0]) {\n    case '.': return dot;\n    case '?': return toggle;\n    case '@': return at;\n    default: return (\n      svg || ('ownerSVGElement' in element) ?\n        (name === 'ref' ? ref : regular) :\n        (attr.get(name) || (\n          name in element ?\n            (name.startsWith('on') ?\n              direct :\n              (gPD(element, name)?.set ? maybeDirect : regular)\n            ) :\n            regular\n          )\n        )\n    );\n  }\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const text = (element, value) => (\n  (element.textContent = value == null ? '' : value),\n  value\n);\n", "import { empty } from './utils.js';\n\n/** @typedef {import(\"./persistent-fragment.js\").PersistentFragment} PersistentFragment */\n/** @typedef {import(\"./rabbit.js\").Hole} Hole */\n\n/** @typedef {unknown} Value */\n/** @typedef {Node | Element | PersistentFragment} Target */\n/** @typedef {null | undefined | string | number | boolean | Node | Element | PersistentFragment} DOMValue */\n/** @typedef {Hole | Node} ArrayValue */\n\nexport const abc = (a, b, c) => ({ a, b, c });\n\nexport const bc = (b, c) => ({ b, c });\n\n/**\n * @typedef {Object} Detail\n * @property {any} v the current value of the interpolation / hole\n * @property {function} u the callback to update the value\n * @property {Node} t the target comment node or element\n * @property {string | null | Node} n the attribute name, if any, or `null`\n * @property {Cache | ArrayValue[] | null} c the cache value for this detail\n */\n\n/**\n * @returns {Detail}\n */\nexport const detail = (u, t, n, c) => ({ v: empty, u, t, n, c });\n\n/**\n * @typedef {Object} Entry\n * @property {number[]} a the path to retrieve the node\n * @property {function} b the update function\n * @property {string | null} c the attribute name, if any, or `null`\n */\n\n/**\n * @typedef {Object} Cache\n * @property {null | TemplateStringsArray} a the cached template\n * @property {null | Node | PersistentFragment} b the node returned when parsing the template\n * @property {Detail[]} c the list of updates to perform\n */\n\n/**\n * @returns {Cache}\n */\nexport const cache = () => abc(null, null, empty);\n", "import { PersistentFragment } from './persistent-fragment.js';\nimport { bc, detail } from './literals.js';\nimport { array, hole } from './handler.js';\nimport { empty, find } from './utils.js';\nimport { cache } from './literals.js';\n\n/** @param {(template: TemplateStringsArray, values: any[]) => import(\"./parser.js\").Resolved} parse */\nexport default parse => (\n  /**\n   * @param {TemplateStringsArray} template\n   * @param {any[]} values\n   * @returns {import(\"./literals.js\").Cache}\n   */\n  (template, values) => {\n    const { a: fragment, b: entries, c: direct } = parse(template, values);\n    const root = document.importNode(fragment, true);\n    /** @type {import(\"./literals.js\").Detail[]} */\n    let details = empty;\n    if (entries !== empty) {\n      details = [];\n      for (let current, prev, i = 0; i < entries.length; i++) {\n        const { a: path, b: update, c: name } = entries[i];\n        const node = path === prev ? current : (current = find(root, (prev = path)));\n        details[i] = detail(\n          update,\n          node,\n          name,\n          update === array ? [] : (update === hole ? cache() : null)\n        );\n      }\n    }\n    return bc(\n      direct ? root.firstChild : new PersistentFragment(root),\n      details,\n    );\n  }\n);\n", "export const TEXT_ELEMENTS = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\nexport const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n", "import { VOID_ELEMENTS } from 'domconstants/re';\n\nconst elements = /<([a-zA-Z0-9]+[a-zA-Z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} xml enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, xml) => {\n  let i = 0;\n  return template\n    .join('\\x01')\n    .trim()\n    .replace(\n      elements,\n      (_, name, attrs, selfClosing) => `<${ name }${ attrs.replace(attributes, '\\x02=$2$1').trimEnd() }${ selfClosing ? ( (xml || VOID_ELEMENTS.test(name)) ? ' /' :`></${name}`) : '' }>`\n    )\n    .replace(\n      holes,\n      hole => hole === '\\x01' ? `<!--${prefix + i++}-->` : (prefix + i++)\n    )\n  ;\n};\n", "import { SVG_NAMESPACE, newRange } from './utils.js';\n\nlet template = document.createElement('template'), svg, range;\n\n/**\n * @param {string} text\n * @param {boolean} xml\n * @returns {DocumentFragment}\n */\nexport default (text, xml) => {\n  if (xml) {\n    if (!svg) {\n      svg = document.createElementNS(SVG_NAMESPACE, 'svg');\n      range = newRange();\n      range.selectNodeContents(svg);\n    }\n    return range.createContextualFragment(text);\n  }\n  template.innerHTML = text;\n  const { content } = template;\n  template = template.cloneNode(false);\n  return content;\n};\n", "import { COMMENT_NODE, ELEMENT_NODE } from 'domconstants/constants';\nimport { TEXT_ELEMENTS } from 'domconstants/re';\nimport parser from '@webreflection/uparser';\n\nimport { empty, isArray, set } from './utils.js';\nimport { abc } from './literals.js';\n\nimport { array, attribute, hole, text, removeAttribute } from './handler.js';\nimport createContent from './create-content.js';\n\n/** @typedef {import(\"./literals.js\").Entry} Entry */\n\n/**\n * @typedef {Object} Resolved\n * @param {DocumentFragment} f content retrieved from the template\n * @param {Entry[]} e entries per each hole in the template\n * @param {boolean} d direct node to handle\n */\n\n/**\n * @param {Element} node\n * @returns {number[]}\n */\nconst createPath = node => {\n  const path = [];\n  let parentNode;\n  while ((parentNode = node.parentNode)) {\n    path.push(path.indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n  }\n  return path;\n};\n\nconst textNode = () => document.createTextNode('');\n\n/**\n * @param {TemplateStringsArray} template\n * @param {boolean} xml\n * @returns {Resolved}\n */\nconst resolve = (template, values, xml) => {\n  const content = createContent(parser(template, prefix, xml), xml);\n  const { length } = template;\n  let entries = empty;\n  if (length > 1) {\n    const replace = [];\n    const tw = document.createTreeWalker(content, 1 | 128);\n    let i = 0, search = `${prefix}${i++}`;\n    entries = [];\n    while (i < length) {\n      const node = tw.nextNode();\n      // these are holes or arrays\n      if (node.nodeType === COMMENT_NODE) {\n        if (node.data === search) {\n          // \u26A0\uFE0F once array, always array!\n          const update = isArray(values[i - 1]) ? array : hole;\n          if (update === hole) replace.push(node);\n          entries.push(abc(createPath(node), update, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n      else {\n        let path;\n        // these are attributes\n        while (node.hasAttribute(search)) {\n          if (!path) path = createPath(node);\n          const name = node.getAttribute(search);\n          entries.push(abc(path, attribute(node, name, xml), name));\n          removeAttribute(node, search);\n          search = `${prefix}${i++}`;\n        }\n        // these are special text-only nodes\n        if (\n          !xml &&\n          TEXT_ELEMENTS.test(node.localName) &&\n          node.textContent.trim() === `<!--${search}-->`\n        ) {\n          entries.push(abc(path || createPath(node), text, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n    }\n    // can't replace holes on the fly or the tree walker fails\n    for (i = 0; i < replace.length; i++)\n      replace[i].replaceWith(textNode());\n  }\n\n  // need to decide if there should be a persistent fragment\n  const { childNodes } = content;\n  let { length: len } = childNodes;\n\n  // html`` or svg`` to signal an empty content\n  // these nodes can be passed directly as never mutated\n  if (len < 1) {\n    len = 1;\n    content.appendChild(textNode());\n  }\n  // html`${'b'}` or svg`${[]}` cases\n  else if (\n    len === 1 &&\n    // ignore html`static` or svg`static` because\n    // these nodes can be passed directly as never mutated\n    length !== 1 &&\n    childNodes[0].nodeType !== ELEMENT_NODE\n  ) {\n    // use a persistent fragment for these cases too\n    len = 0;\n  }\n\n  return set(cache, template, abc(content, entries, len === 1));\n};\n\n/** @type {WeakMap<TemplateStringsArray, Resolved>} */\nconst cache = new WeakMap;\nconst prefix = 'is\u00B5';\n\n/**\n * @param {boolean} xml\n * @returns {(template: TemplateStringsArray, values: any[]) => Resolved}\n */\nexport default xml => (template, values) => cache.get(template) || resolve(template, values, xml);\n", "import { array, hole } from './handler.js';\nimport { cache } from './literals.js';\nimport create from './creator.js';\nimport parser from './parser.js';\n\nconst createHTML = create(parser(false));\nconst createSVG = create(parser(true));\n\n/**\n * @param {import(\"./literals.js\").Cache} info\n * @param {Hole} hole\n * @returns {Node}\n */\nconst unroll = (info, { s, t, v }) => {\n  if (info.a !== t) {\n    const { b, c } = (s ? createSVG : createHTML)(t, v);\n    info.a = t;\n    info.b = b;\n    info.c = c;\n  }\n  for (let { c } = info, i = 0; i < c.length; i++) {\n    const value = v[i];\n    const detail = c[i];\n    switch (detail.u) {\n      case array:\n        detail.v = array(\n          detail.t,\n          unrollValues(detail.c, value),\n          detail.v\n        );\n        break;\n      case hole:\n        const current = value instanceof Hole ?\n          unroll(detail.c || (detail.c = cache()), value) :\n          (detail.c = null, value)\n        ;\n        if (current !== detail.v)\n          detail.v = hole(detail, current);\n        break;\n      default:\n        if (value !== detail.v)\n          detail.v = detail.u(detail.t, value, detail.n, detail.v);\n        break;\n    }\n  }\n  return info.b;\n};\n\n/**\n * @param {Cache} cache\n * @param {any[]} values\n * @returns {number}\n */\nconst unrollValues = (stack, values) => {\n  let i = 0, { length } = values;\n  if (length < stack.length) stack.splice(length);\n  for (; i < length; i++) {\n    const value = values[i];\n    if (value instanceof Hole)\n      values[i] = unroll(stack[i] || (stack[i] = cache()), value);\n    else stack[i] = null;\n  }\n  return values;\n};\n\n/**\n * Holds all details needed to render the content on a render.\n * @constructor\n * @param {boolean} svg The content type.\n * @param {TemplateStringsArray} template The template literals used to the define the content.\n * @param {any[]} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(svg, template, values) {\n    this.s = svg;\n    this.t = template;\n    this.v = values;\n  }\n  toDOM(info = cache()) {\n    return unroll(info, this);\n  }\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\n\nimport render from './render/hole.js';\n\n/** @typedef {import(\"./literals.js\").Value} Value */\n\nconst tag = svg => (template, ...values) => new Hole(svg, template, values);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render HTML content. */\nexport const html = tag(false);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render SVG content. */\nexport const svg = tag(true);\n\nexport { Hole, render, attr };\n", "import { Hole } from '../rabbit.js';\nimport { cache } from '../literals.js';\nimport { set } from '../utils.js';\n\n/** @type {WeakMap<Element | DocumentFragment, import(\"../literals.js\").Cache>} */\nconst known = new WeakMap;\n\n/**\n  * Render with smart updates within a generic container.\n  * @template T\n  * @param {T} where the DOM node where to render content\n  * @param {(() => Hole) | Hole} what the hole to render\n  * @param {boolean} check does a `typeof` check (internal usage).\n  * @returns\n  */\nexport default (where, what, check) => {\n  const info = known.get(where) || set(known, where, cache());\n  const { b } = info;\n  const hole = (check && typeof what === 'function') ? what() : what;\n  const node = hole instanceof Hole ? hole.toDOM(info) : hole;\n  if (b !== node)\n    where.replaceChildren((info.b = node).valueOf());\n  return where;\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\nimport { cache } from './literals.js';\nimport { set } from './utils.js';\nimport { html, svg } from './index.js';\n\nimport render from './render/keyed.js';\n\n/** @typedef {import(\"./literals.js\").Cache} Cache */\n/** @typedef {import(\"./literals.js\").Target} Target */\n/** @typedef {import(\"./literals.js\").Value} Value */\n\n/** @typedef {(ref:Object, key:string | number) => Tag} Bound */\n\n/**\n * @callback Tag\n * @param {TemplateStringsArray} template\n * @param  {...Value} values\n * @returns {Target}\n */\n\nconst keyed = new WeakMap;\nconst createRef = svg => /** @type {Bound} */ (ref, key) => {\n  /** @type {Tag} */\n  function tag(template, ...values) {\n    return new Hole(svg, template, values).toDOM(this);\n  }\n\n  const memo = keyed.get(ref) || set(keyed, ref, new Map);\n  return memo.get(key) || set(memo, key, tag.bind(cache()));\n};\n\n/** @type {Bound} Returns a bound tag to render HTML content. */\nexport const htmlFor = createRef(false);\n\n/** @type {Bound} Returns a bound tag to render SVG content. */\nexport const svgFor = createRef(true);\n\nexport { Hole, render, html, svg, attr };\n", "// (c) Andrea Giammarchi - ISC\n\nconst registry = new FinalizationRegistry(\n  ([onGarbageCollected, held, debug]) => {\n    // \"%cThis is a green text\", \"color:green\"\n    if (debug) console.debug(`%c${String(held)}`, 'font-weight:bold', 'collected');\n    onGarbageCollected(held);\n  }\n);\n\nconst nullHandler = Object.create(null);\n\n/**\n * @template {unknown} H\n * @typedef {Object} GCHookOptions\n * @prop {boolean} [debug=false] if `true`, logs values once these can get collected.\n * @prop {ProxyHandler<object>} [handler] optional proxy handler to use instead of the default one.\n * @prop {H} [return=H] if specified, overrides the returned proxy with its value.\n * @prop {unknown} [token=H] it's the held value by default, but it can be any other token except the returned value itself.\n */\n\n/**\n * @template {unknown} H\n * @param {H} hold the reference to hold behind the scene and passed along the callback once it triggers.\n * @param {(held:H) => void} onGarbageCollected the callback that will receive the held value once its wrapper or indirect reference is no longer needed.\n * @param {GCHookOptions<H>} [options] an optional configuration object to change some default behavior.\n */\nexport const create = (\n  hold,\n  onGarbageCollected,\n  { debug, handler, return: r, token = hold } = nullHandler\n) => {\n  // if no reference to return is defined,\n  // create a proxy for the held one and register that instead.\n  /** @type {H} */\n  const target = r || new Proxy(hold, handler || nullHandler);\n  const args = [target, [onGarbageCollected, hold, !!debug]];\n  if (token !== false) args.push(token);\n  // register the target reference in a way that\n  // the `onGarbageCollected(held)` callback will eventually notify.\n  registry.register(...args);\n  return target;\n};\n\n/**\n * If previously registered as either `token` or `hold` value, allow explicit removal of the entry in the registry.\n * @param {unknown} token the token used during registration. If no `token` was passed, this can be the same `hold` reference.\n * @returns {boolean} `true` if successfully unregistered.\n */\nexport const drop = token => registry.unregister(token);\n", "import { create, drop } from 'gc-hook';\n\nimport render from './shared.js';\n\n/** @typedef {import(\"../rabbit.js\").Hole} Hole */\n\n/** @type {WeakMap<Element | DocumentFragment, Function>} */\nconst effects = new WeakMap;\n\n/**\n * @param {Function} dispose\n * @returns {void}\n */\nconst onGC = dispose => dispose();\n\nlet remove = true;\n\n/**\n * @param {Function} effect the reactive `effect` callback provided by a 3rd party library.\n * @returns \n */\nexport const attach = effect => {\n  /**\n   * Render with smart updates within a generic container.\n   * If the `what` is a function, it automatically create\n   * an effect for the render function.\n   * @template T\n   * @param {T} where the DOM node where to render content\n   * @param {(() => Hole) | Hole} what the hole to render\n   * @returns {T}\n   */\n  return (where, what) => {\n    remove = typeof what !== 'function';\n    detach(where);\n\n    if (remove) return render(where, what, false);\n    remove = true;\n\n    const wr = new WeakRef(where);\n    const dispose = effect(() => { render(wr.deref(), what(), false) });\n    effects.set(where, dispose);\n    return create(dispose, onGC, { return: where });\n  };\n};\n\n/**\n * Allow manual cleanup of subscribed signals.\n * @param {Element} where a reference container previously used to render signals.\n */\nexport const detach = where => {\n  const dispose = effects.get(where);\n  if (dispose) {\n    if (remove) effects.delete(where);\n    drop(dispose);\n    dispose();\n  }\n};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(() => {\n\t\tconst value = this.value;\n\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n\treturn new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(fn: EffectFn);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n\tconst effect = new Effect(fn);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { computed, effect, batch, untracked, Signal, ReadonlySignal };\n", "import { ReadonlySignal, Signal, signal as createSignal, computed as preactComputed } from '@preact/signals-core';\r\nimport { ComputedProperties } from './component';\r\n\r\n\r\nexport class State<T> extends Signal<T> {\r\n    emit(value: Partial<T> | T): void {\r\n        if (typeof value === 'object' && value !== null && typeof this.value === 'object') {\r\n            const currentClone = cloneDeep(this.value);\r\n            this.value = { ...currentClone, ...value } as T;\r\n        } else {\r\n            this.value = value as T;\r\n        }\r\n    }\r\n}\r\n\r\nexport function createState<T>(initialValue: T): State<T> {\r\n    const baseSignal = createSignal(initialValue);\r\n    Object.setPrototypeOf(baseSignal, State.prototype);\r\n    return baseSignal as State<T>;\r\n}\r\n\r\n\r\nfunction cloneDeep<T>(obj: T): T {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n        return obj.map(cloneDeep) as unknown as T;\r\n    }\r\n\r\n    const clonedObj: Record<PropertyKey, any> = {};\r\n    for (const key of Reflect.ownKeys(obj)) {\r\n        clonedObj[key as keyof typeof obj] = cloneDeep((obj as Record<PropertyKey, any>)[key]);\r\n    }\r\n\r\n    return clonedObj as T;\r\n}\r\n\r\nexport type ComputedResult<T, Args extends any[]> = (...args: Args) => T;\r\n\r\nexport function compute<R, Args extends any[]>(\r\n    computeFn: (...args: Args) => R\r\n): ComputedResult<R, Args> {\r\n    return (...args: Args) => {\r\n        const signal = preactComputed(() => computeFn(...args));\r\n        return signal.value;\r\n    };\r\n}\r\n\r\n\r\nexport function createComputed<C extends Record<string, (...args: any[]) => any>>(\r\n    computedFn: () => C\r\n): ComputedProperties<C> {\r\n    const computedSignals = new Map<string, any>();\r\n    const computedCache = new Map<string, Map<string, any>>(); // \u041A\u044D\u0448 \u0434\u043B\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0439 \u0441 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430\u043C\u0438\r\n\r\n    const computed = Object.entries(computedFn()).reduce((acc, [key, fn]) => {\r\n        if (fn.length === 0) {\r\n            // \u041A\u044D\u0448\u0438\u0440\u0443\u0435\u043C \u0432\u044B\u0447\u0438\u0441\u043B\u0435\u043D\u0438\u044F \u0431\u0435\u0437 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432\r\n            if (!computedSignals.has(key)) {\r\n                computedSignals.set(key, preactComputed(() => fn()));\r\n            }\r\n            return {\r\n                ...acc,\r\n                [key]: () => computedSignals.get(key).value,\r\n            };\r\n        }\r\n\r\n        // \u0414\u043B\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0439 \u0441 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430\u043C\u0438 \u0441\u043E\u0437\u0434\u0430\u0451\u043C \u043A\u044D\u0448\r\n        return {\r\n            ...acc,\r\n            [key]: (...args: any[]) => {\r\n                const cacheKey = JSON.stringify(args); // \u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F \u043A\u043B\u044E\u0447\u0430 \u0434\u043B\u044F \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432\r\n                let argCache = computedCache.get(key);\r\n\r\n                if (!argCache) {\r\n                    argCache = new Map<string, any>();\r\n                    computedCache.set(key, argCache);\r\n                }\r\n\r\n                if (!argCache.has(cacheKey)) {\r\n                    const signal = preactComputed(() => fn(...args));\r\n                    argCache.set(cacheKey, signal);\r\n                }\r\n\r\n                return argCache.get(cacheKey).value;\r\n            },\r\n        };\r\n    }, {} as ComputedProperties<C>);\r\n\r\n    return computed;\r\n}\r\n", "import { ReadonlySignal, Signal, computed as preactComputed } from '@preact/signals-core';\r\n\r\ninterface ComputedCache<T> {\r\n    signal: Signal<T>;\r\n    args: unknown[];\r\n    lastAccessed: number;\r\n}\r\n\r\nexport class ComputedManager {\r\n    private static maxCacheSize = 1000;\r\n    private static cleanupThreshold = 0.8; // 80% of maxCacheSize\r\n    private static cacheTimeout = 5 * 60 * 1000; // 5 minutes\r\n\r\n    private static createCacheKey(args: unknown[]): string {\r\n        return args.map(arg => {\r\n            if (arg === null) return 'null';\r\n            if (arg === undefined) return 'undefined';\r\n            if (typeof arg === 'object') {\r\n                // Try to use id or similar unique identifier first\r\n                const obj = arg as Record<string, unknown>;\r\n                if ('id' in obj) return String(obj.id);\r\n                if ('key' in obj) return String(obj.key);\r\n                // Fall back to stable stringification for objects\r\n                return JSON.stringify(this.sortObjectKeys(obj));\r\n            }\r\n            return String(arg);\r\n        }).join('|');\r\n    }\r\n\r\n    private static sortObjectKeys<T extends object>(obj: T): T {\r\n        if (Array.isArray(obj)) {\r\n            return obj.map(item =>\r\n                typeof item === 'object' && item !== null ? this.sortObjectKeys(item) : item\r\n            ) as unknown as T;\r\n        }\r\n        return Object.keys(obj)\r\n            .sort()\r\n            .reduce((acc, key) => {\r\n                const value = obj[key as keyof T];\r\n                (acc as any)[key] = typeof value === 'object' && value !== null\r\n                    ? this.sortObjectKeys(value)\r\n                    : value;\r\n                return acc;\r\n            }, {} as T);\r\n    }\r\n\r\n    private static argsEqual(a: unknown[], b: unknown[]): boolean {\r\n        if (a.length !== b.length) return false;\r\n        return a.every((val, i) => {\r\n            if (Object.is(val, b[i])) return true;\r\n            if (typeof val === 'object' && val && typeof b[i] === 'object' && b[i]) {\r\n                return JSON.stringify(this.sortObjectKeys(val as object)) ===\r\n                    JSON.stringify(this.sortObjectKeys(b[i] as object));\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    public static createComputed<T, Args extends unknown[]>(\r\n        fn: (...args: Args) => T,\r\n        options: {\r\n            maxAge?: number;\r\n            cacheSize?: number;\r\n        } = {}\r\n    ): (...args: Args) => T {\r\n        const cache = new Map<string, ComputedCache<T>>();\r\n        const maxAge = options.maxAge ?? this.cacheTimeout;\r\n        const maxSize = options.cacheSize ?? this.maxCacheSize;\r\n\r\n        return (...args: Args): T => {\r\n            // For computed without arguments, we can just create a single signal\r\n            if (args.length === 0) {\r\n                if (!cache.has('_')) {\r\n                    const signal = preactComputed(() => fn(...args));\r\n                    cache.set('_', {\r\n                        signal,\r\n                        args: [],\r\n                        lastAccessed: Date.now()\r\n                    });\r\n                }\r\n                const cached = cache.get('_')!;\r\n                cached.lastAccessed = Date.now();\r\n                return cached.signal.value;\r\n            }\r\n\r\n            const cacheKey = this.createCacheKey(args);\r\n            const cached = cache.get(cacheKey);\r\n\r\n            // Check cache and args equality\r\n            if (cached && this.argsEqual(cached.args, args)) {\r\n                const now = Date.now();\r\n                if (now - cached.lastAccessed <= maxAge) {\r\n                    cached.lastAccessed = now;\r\n                    return cached.signal.value;\r\n                }\r\n            }\r\n\r\n            // Clean up cache if needed\r\n            if (cache.size >= maxSize * this.cleanupThreshold) {\r\n                this.cleanup(cache, maxAge);\r\n            }\r\n\r\n            // Create new computed\r\n            const signal = preactComputed(() => fn(...args));\r\n            cache.set(cacheKey, {\r\n                signal,\r\n                args: [...args],\r\n                lastAccessed: Date.now()\r\n            });\r\n\r\n            return signal.value;\r\n        };\r\n    }\r\n\r\n    private static cleanup<T>(\r\n        cache: Map<string, ComputedCache<T>>,\r\n        maxAge: number\r\n    ): void {\r\n        const now = Date.now();\r\n        for (const [key, value] of cache.entries()) {\r\n            if (now - value.lastAccessed > maxAge) {\r\n                cache.delete(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function createComputedProperty<T, Args extends unknown[]>(\r\n    fn: (...args: Args) => T,\r\n    options?: { maxAge?: number; cacheSize?: number }\r\n): (...args: Args) => T {\r\n    return ComputedManager.createComputed(fn, options);\r\n}\r\n\r\nexport type ComputedProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReadonlySignal<ReturnType<C[K]>>\r\n    : never;\r\n};\r\n\r\nexport type InferComputedType<T> = T extends (...args: any[]) => any\r\n    ? ReturnType<T>\r\n    : never;", "import { State, createState } from './state';\r\nimport { ComputedProperties, GettersProperties } from './component';\r\nimport { ComputedManager } from './untils';\r\n\r\ntype ComputedFn<S> = (context: {\r\n    state: State<S>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\ntype ActionsFn<S, C> = (context: {\r\n    state: State<S>;\r\n    computed: ComputedProperties<C>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\ntype GettersFn<S> = ComputedFn<S>;\r\n\r\nexport interface StoreOptions<S = any, G extends GettersFn<S> = any, C extends ComputedFn<S> = any, A extends ActionsFn<S, ReturnType<C>> = any> {\r\n    state: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n}\r\n\r\nexport interface StoreContext<S, G extends GettersFn<S>, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>> {\r\n    state: State<S>;\r\n    getters: GettersProperties<ReturnType<G>>;\r\n    computed: ComputedProperties<ReturnType<C>>;\r\n    actions: ReturnType<A>;\r\n}\r\n\r\nexport interface GlobalStore extends Record<string, StoreContext<any, any, any, any>> { }\r\n\r\nexport interface StoreRegistry {\r\n    list: Partial<GlobalStore>;\r\n    $: <K extends keyof GlobalStore, >(key: K) => GlobalStore[K];\r\n    register: <K extends keyof GlobalStore>(\r\n        key: K,\r\n        store: GlobalStore[K]\r\n    ) => void;\r\n}\r\n\r\nconst globalStore: Partial<GlobalStore> = {};\r\n\r\nexport function createStore<S, G extends GettersFn<S>, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>>(\r\n    options: StoreOptions<S, G, C, A>\r\n): StoreContext<S, G, C, A> {\r\n    const { state: initialState, getters: gettersFn, computed: computedFn, actions: actionsFn } = options;\r\n\r\n    const state = createState(initialState);\r\n\r\n    const getters = gettersFn\r\n        ? Object.entries(gettersFn({ state })).reduce((acc, [key, fn]) => ({\r\n            ...acc,\r\n            [key]: fn()\r\n        }), {}) as GettersProperties<ReturnType<G>>\r\n        : ({} as GettersProperties<ReturnType<G>>);\r\n\r\n    // \u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 computed\r\n    const computed = computedFn\r\n        ? Object.entries(computedFn({ state })).reduce((acc, [key, fn]) => {\r\n            const computedProperty = ComputedManager.createComputed(\r\n                () => fn(),\r\n                {\r\n                    maxAge: 15 * 60 * 1000, // 15 \u043C\u0438\u043D\u0443\u0442 \u0434\u043B\u044F store computed\r\n                    cacheSize: 500 // \u0431\u043E\u043B\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F store\r\n                }\r\n            );\r\n\r\n            return {\r\n                ...acc,\r\n                [key]: {\r\n                    get value() {\r\n                        return computedProperty();\r\n                    }\r\n                }\r\n            };\r\n        }, {}) as ComputedProperties<ReturnType<C>>\r\n        : ({} as ComputedProperties<ReturnType<C>>);\r\n\r\n    const actions = actionsFn\r\n        ? (actionsFn({\r\n            state,\r\n            computed\r\n        }) as ReturnType<A>)\r\n        : ({} as ReturnType<A>);\r\n\r\n    return { state, getters, computed, actions };\r\n}\r\n\r\nfunction registerStore<K extends keyof GlobalStore>(\r\n    key: K,\r\n    store: GlobalStore[K]\r\n): void {\r\n    if (globalStore[key]) {\r\n        throw new Error(`Store \"${key}\" already exists`);\r\n    }\r\n    globalStore[key] = store;\r\n\r\n}\r\n\r\nfunction getStore<K extends keyof GlobalStore>(key: K): GlobalStore[K] {\r\n    const store = globalStore[key];\r\n    if (!store) {\r\n        throw new Error(`Store \"${key}\" not found`);\r\n    }\r\n    return store;\r\n}\r\n\r\nexport function defineStore<\r\n    S extends object,\r\n    G extends GettersFn<S>,\r\n    C extends Record<string, (...args: any[]) => any>,\r\n    A extends ActionsFn<S, C>\r\n>(options: {\r\n    key: keyof GlobalStore;\r\n    state: S;\r\n    getters?: G;\r\n    computed?: (context: { state: State<S> }) => C;\r\n    actions?: A;\r\n}) {\r\n    const { key, state, ...rest } = options;\r\n    const store = createStore({ state: state, ...rest });\r\n    storeRegistry.register(key, store);\r\n    return store;\r\n}\r\n\r\nexport const storeRegistry: StoreRegistry = {\r\n    list: globalStore,\r\n    $: getStore,\r\n    register: registerStore,\r\n};", "import { reactive } from 'uhtml/reactive';\r\nimport { effect, ReadonlySignal, Signal, signal, computed as preactComputed } from '@preact/signals-core';\r\nimport { State, createState } from './state';\r\nimport { StoreRegistry, storeRegistry } from './store';\r\nimport { ComputedManager } from './untils';\r\n\r\ntype ConstructorToType<T> =\r\n    T extends StringConstructor ? string :\r\n    T extends NumberConstructor ? number :\r\n    T extends BooleanConstructor ? boolean :\r\n    T extends ArrayConstructor ? T[] :\r\n    T extends ObjectConstructor ? Record<string, unknown> :\r\n    T;\r\n\r\ntype ModelPropDefinition<T> = {\r\n    type: TypeConstructor;\r\n    default?: T;\r\n    model?: { __type: T };\r\n};\r\n\r\ntype SimplePropDefinition<T extends TypeConstructor> = {\r\n    type: T;\r\n    default?: ConstructorToType<T>;\r\n};\r\n\r\ntype PropDefinition<T = unknown> =\r\n    T extends TypeConstructor\r\n    ? SimplePropDefinition<T>\r\n    : ModelPropDefinition<T>;\r\n\r\ntype InferPropType<T> =\r\n    T extends SimplePropDefinition<infer U>\r\n    ? ConstructorToType<U>\r\n    : T extends ModelPropDefinition<infer M>\r\n    ? M\r\n    : never;\r\n\r\ntype InferProps<T extends Record<string, PropDefinition>> = {\r\n    [K in keyof T]: InferPropType<T[K]>;\r\n};\r\n\r\nexport type ComputedProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReturnType<C[K]>\r\n    : never;\r\n};\r\n\r\nexport type GettersProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReturnType<C[K]>\r\n    : never;\r\n};\r\n\r\ntype TypeConstructor =\r\n    | StringConstructor\r\n    | NumberConstructor\r\n    | BooleanConstructor\r\n    | ObjectConstructor\r\n    | ArrayConstructor;\r\n\r\ntype BaseContext<P, S> = {\r\n    props: P;\r\n    el: CustomHtmlElement;\r\n    slots: Record<string, Node[]>,\r\n    state: State<S>;\r\n    store: StoreRegistry;\r\n};\r\n\r\ntype GettersFn<P, S> = (context: BaseContext<P, S>) => Record<string, () => any>;\r\ntype ComputedFn<P, S> = (context: BaseContext<P, S>) => Record<string, () => any>;\r\ntype ActionsFn<P, S, C> = (context: BaseContext<P, S> & {\r\n    computed: ComputedProperties<C>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\nexport interface ComponentContext<\r\n    P,\r\n    S,\r\n    G extends GettersFn<P, S>,\r\n    C extends ComputedFn<P, S>,\r\n    A extends ActionsFn<P, S, ReturnType<C>>\r\n> {\r\n    props: P;\r\n    state: State<S>;\r\n    getters: GettersProperties<ReturnType<G>>;\r\n    computed: ComputedProperties<ReturnType<C>>;\r\n    actions: ReturnType<A>;\r\n    el: CustomHtmlElement;\r\n    slots: Record<string, Node[]>;\r\n    store: StoreRegistry;\r\n}\r\n\r\nexport interface CustomHtmlElement extends HTMLElement {\r\n    $<T = any>(key: string): T | undefined;\r\n    emitEvent<T = any>(name: string, detail?: T): void;\r\n}\r\n\r\nexport interface ComponentOptions2<\r\n    P extends Record<string, PropDefinition> = any,\r\n    S = any,\r\n    G extends GettersFn<InferProps<P>, S> = any,\r\n    C extends ComputedFn<InferProps<P>, S> = any,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>> = any\r\n> {\r\n    tagName: string;\r\n    props?: P;\r\n    state?: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n    connected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n    render?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => unknown;\r\n    listen?: (params: ComponentContext<InferProps<P>, S, G, C, A> & {\r\n        newValue: S;\r\n        oldValue: S;\r\n    }) => void;\r\n    disconnected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n}\r\n\r\n\r\n\r\ntype ComponentOptions<\r\n    P extends Record<string, PropDefinition>,\r\n    S,\r\n    G extends GettersFn<InferProps<P>, S>,\r\n    C extends ComputedFn<InferProps<P>, S>,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>>\r\n> = {\r\n    tagName: string;\r\n    props?: P;\r\n    state?: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n    connected?: (ctx: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n    render?: (ctx: ComponentContext<InferProps<P>, S, G, C, A>) => unknown;\r\n    listen?: (ctx: ComponentContext<InferProps<P>, S, G, C, A> & {\r\n        newValue: S;\r\n        oldValue: S;\r\n    }) => void;\r\n    disconnected?: (ctx: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n};\r\n\r\n\r\nexport function defineComponent<\r\n    P extends Record<string, PropDefinition>,\r\n    S,\r\n    G extends GettersFn<InferProps<P>, S>,\r\n    C extends ComputedFn<InferProps<P>, S>,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>>\r\n>(options: ComponentOptions<P, S, G, C, A>) {\r\n    const {\r\n        tagName,\r\n        props: propsDefinition = {} as P,\r\n        state: initialState,\r\n        getters: gettersFn = (() => ({})) as GettersFn<InferProps<P>, S>,\r\n        computed: computedFn = (() => ({})) as ComputedFn<InferProps<P>, S>,\r\n        actions: actionsFn = (() => ({})) as ActionsFn<InferProps<P>, S, ReturnType<ComputedFn<InferProps<P>, S>>>,\r\n        connected,\r\n        disconnected,\r\n        render,\r\n        listen\r\n    } = options;\r\n\r\n    const uRender = reactive(effect);\r\n\r\n    class CustomElement extends HTMLElement implements CustomHtmlElement {\r\n        props: Signal<InferProps<P>>;\r\n        state: State<S>;\r\n        getters: GettersProperties<ReturnType<G>>;\r\n        computed: ComputedProperties<ReturnType<C>>;\r\n        actions: ReturnType<A>;\r\n        slots: Record<string, Node[]> = {};\r\n        cleanup: (() => void)[] = [];\r\n\r\n        static get observedAttributes() {\r\n            return Object.keys(propsDefinition).map((name) => `data-${name}`);\r\n        }\r\n\r\n        constructor() {\r\n            super();\r\n            this.props = signal({} as InferProps<P>);\r\n            this.props.value = this.initializeProps();\r\n            this.state = createState(initialState as S);\r\n            this.getters = this.setupGetters();\r\n            this.computed = this.setupComputed();\r\n            this.actions = this.setupActions();\r\n        }\r\n\r\n        public $<T = any>(key: string) {\r\n            return (this as any)[key] as T | undefined;\r\n        }\r\n\r\n        public emitEvent<T = any>(name: string, detail: T = {} as T): void {\r\n            this.dispatchEvent(new CustomEvent(name, { detail }));\r\n        }\r\n\r\n        setupGetters(): GettersProperties<ReturnType<G>> {\r\n            const getterObj = gettersFn({\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            });\r\n\r\n            return Object.entries(getterObj).reduce((acc, [key, fn]) => ({\r\n                ...acc,\r\n                [key]: fn()\r\n            }), {}) as GettersProperties<ReturnType<G>>;\r\n        }\r\n\r\n        setupComputed(): ComputedProperties<ReturnType<C>> {\r\n            const context = {\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            };\r\n\r\n            const computedObj = computedFn(context);\r\n            const computed = {} as ComputedProperties<ReturnType<C>>;\r\n\r\n            // \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C ComputedManager \u0434\u043B\u044F \u043A\u0430\u0436\u0434\u043E\u0433\u043E computed \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\r\n            for (const [key, fn] of Object.entries(computedObj)) {\r\n                const computedProperty = ComputedManager.createComputed(\r\n                    () => fn(),\r\n                    {\r\n                        maxAge: 5 * 60 * 1000, // 5 \u043C\u0438\u043D\u0443\u0442 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432\r\n                        cacheSize: 100 // \u043C\u0435\u043D\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432\r\n                    }\r\n                );\r\n\r\n                Object.defineProperty(computed, key, {\r\n                    get: () => computedProperty(),\r\n                    enumerable: true\r\n                });\r\n            }\r\n\r\n            return computed;\r\n        }\r\n\r\n        setupActions(): ReturnType<A> {\r\n            return actionsFn({\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                computed: this.computed,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            }) as ReturnType<A>;\r\n        }\r\n\r\n        get context(): ComponentContext<InferProps<P>, S, G, C, A> {\r\n            return {\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                getters: this.getters,\r\n                computed: this.computed,\r\n                actions: this.actions,\r\n                el: this,\r\n                slots: this.slots,\r\n                store: storeRegistry,\r\n            };\r\n        }\r\n\r\n        initializeProps(): InferProps<P> {\r\n            const props = {} as InferProps<P>;\r\n            for (const [key, definition] of Object.entries(propsDefinition)) {\r\n                const attrName = `data-${key}`;\r\n                const attrValue = this.getAttribute(attrName);\r\n                const defaultValue = definition.default ?? this.getDefaultForType(definition.type);\r\n                props[key as keyof P] = attrValue !== null\r\n                    ? this.parseAttributeValue(attrValue, definition.type)\r\n                    : defaultValue;\r\n            }\r\n            return props;\r\n        }\r\n\r\n        getDefaultForType(type: PropDefinition['type']): any {\r\n            switch (type) {\r\n                case String: return '';\r\n                case Number: return 0;\r\n                case Boolean: return false;\r\n                case Object: return {};\r\n                case Array: return [];\r\n                default: return null;\r\n            }\r\n        }\r\n\r\n        parseAttributeValue(value: string, type: PropDefinition['type']): any {\r\n            switch (type) {\r\n                case Number:\r\n                    return Number(value);\r\n                case Boolean:\r\n                    return value !== null && value !== 'false';\r\n                case Object:\r\n                case Array:\r\n                    try {\r\n                        return JSON.parse(value);\r\n                    } catch {\r\n                        return type === Object ? {} : [];\r\n                    }\r\n                default:\r\n                    return value;\r\n            }\r\n        }\r\n\r\n        attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n            const propName = name.replace(/^data-/, '');\r\n            const propDef = (propsDefinition as any)[propName];\r\n            if (!propDef) return;\r\n            const value = this.parseAttributeValue(newValue, propDef.type);\r\n            this.updateProp(propName as keyof P, value);\r\n        }\r\n\r\n        updateProp(name: keyof P, value: any) {\r\n            this.props.value = {\r\n                ...this.props.peek(),\r\n                [name]: value,\r\n            };\r\n        }\r\n\r\n        getPropValue() {\r\n            return this.props.value;\r\n        }\r\n\r\n        setupListener() {\r\n            if (!listen) return;\r\n\r\n            let previousValue = this.state.peek();\r\n            const cleanup = effect(() => {\r\n                const currentValue = this.state.value;\r\n                listen({\r\n                    ...this.context,\r\n                    newValue: currentValue,\r\n                    oldValue: previousValue\r\n                });\r\n                previousValue = currentValue;\r\n            });\r\n\r\n            this.cleanup.push(cleanup);\r\n        }\r\n\r\n        setupRender() {\r\n            if (!render) return;\r\n\r\n            const cleanup = uRender(this, () => render(this.context));\r\n            this.cleanup.push(cleanup);\r\n        }\r\n\r\n        collectSlots() {\r\n            const slots: Record<string, Node[]> = { default: [] };\r\n            Array.from(this.childNodes).forEach(node => {\r\n                if (node instanceof Element) {\r\n                    const slotName = node.getAttribute('data-slot') || 'default';\r\n                    slots[slotName] = slots[slotName] || [];\r\n                    slots[slotName].push(node);\r\n                } else if (node.textContent?.trim()) {\r\n                    slots.default.push(node);\r\n                }\r\n            });\r\n            this.slots = slots;\r\n        }\r\n\r\n        connectedCallback() {\r\n            requestAnimationFrame(() => {\r\n                this.collectSlots();\r\n                this.setupListener();\r\n                this.setupRender();\r\n                connected?.(this.context);\r\n            })\r\n        }\r\n\r\n        disconnectedCallback() {\r\n            this.cleanup.forEach(cleanup => cleanup());\r\n            this.cleanup = [];\r\n            disconnected?.(this.context);\r\n        }\r\n    }\r\n    if (tagName) {\r\n        customElements.define(tagName, CustomElement);\r\n    }\r\n}"],
  "mappings": "yxBAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,WAAAE,GAAA,YAAAC,GAAA,mBAAAC,GAAA,gBAAAC,EAAA,gBAAAC,GAAA,oBAAAC,GAAA,gBAAAC,GAAA,WAAAC,EAAA,SAAAC,GAAA,YAAAC,GAAA,mBAAAC,EAAA,kBAAAC,IC2BA,IAAOC,GAAQ,CAACC,EAAYC,EAAGC,EAAGC,EAAKC,IAAW,CAChD,IAAMC,EAAUH,EAAE,OACdI,EAAOL,EAAE,OACTM,EAAOF,EACPG,EAAS,EACTC,EAAS,EACTC,EAAM,KACV,KAAOF,EAASF,GAAQG,EAASF,GAE/B,GAAID,IAASE,EAAQ,CAKnB,IAAMG,EAAOJ,EAAOF,EACjBI,EACEN,EAAID,EAAEO,EAAS,CAAC,EAAG,EAAE,EAAE,YACxBN,EAAID,EAAEK,CAAI,EAAG,CAAC,EAChBH,EACF,KAAOK,EAASF,GACdP,EAAW,aAAaG,EAAID,EAAEO,GAAQ,EAAG,CAAC,EAAGE,CAAI,CACrD,SAESJ,IAASE,EAChB,KAAOD,EAASF,IAEV,CAACI,GAAO,CAACA,EAAI,IAAIT,EAAEO,CAAM,CAAC,IAC5BR,EAAW,YAAYG,EAAIF,EAAEO,CAAM,EAAG,EAAE,CAAC,EAC3CA,YAIKP,EAAEO,CAAM,IAAMN,EAAEO,CAAM,EAC7BD,IACAC,YAGOR,EAAEK,EAAO,CAAC,IAAMJ,EAAEK,EAAO,CAAC,EACjCD,IACAC,YAMAN,EAAEO,CAAM,IAAMN,EAAEK,EAAO,CAAC,GACxBL,EAAEO,CAAM,IAAMR,EAAEK,EAAO,CAAC,EACxB,CAOA,IAAMK,EAAOR,EAAIF,EAAE,EAAEK,CAAI,EAAG,EAAE,EAAE,YAChCN,EAAW,aACTG,EAAID,EAAEO,GAAQ,EAAG,CAAC,EAClBN,EAAIF,EAAEO,GAAQ,EAAG,EAAE,EAAE,WACvB,EACAR,EAAW,aAAaG,EAAID,EAAE,EAAEK,CAAI,EAAG,CAAC,EAAGI,CAAI,EAO/CV,EAAEK,CAAI,EAAIJ,EAAEK,CAAI,CAClB,KAEK,CAMH,GAAI,CAACG,EAAK,CACRA,EAAM,IAAI,IACV,IAAIE,EAAIH,EACR,KAAOG,EAAIL,GACTG,EAAI,IAAIR,EAAEU,CAAC,EAAGA,GAAG,CACrB,CAEA,GAAIF,EAAI,IAAIT,EAAEO,CAAM,CAAC,EAAG,CAEtB,IAAMK,EAAQH,EAAI,IAAIT,EAAEO,CAAM,CAAC,EAE/B,GAAIC,EAASI,GAASA,EAAQN,EAAM,CAClC,IAAIK,EAAIJ,EAEJM,EAAW,EACf,KAAO,EAAEF,EAAIN,GAAQM,EAAIL,GAAQG,EAAI,IAAIT,EAAEW,CAAC,CAAC,IAAOC,EAAQC,GAC1DA,IAWF,GAAIA,EAAYD,EAAQJ,EAAS,CAC/B,IAAME,EAAOR,EAAIF,EAAEO,CAAM,EAAG,CAAC,EAC7B,KAAOC,EAASI,GACdb,EAAW,aAAaG,EAAID,EAAEO,GAAQ,EAAG,CAAC,EAAGE,CAAI,CACrD,MAKEX,EAAW,aACTG,EAAID,EAAEO,GAAQ,EAAG,CAAC,EAClBN,EAAIF,EAAEO,GAAQ,EAAG,EAAE,CACrB,CAEJ,MAGEA,GACJ,MAKER,EAAW,YAAYG,EAAIF,EAAEO,GAAQ,EAAG,EAAE,CAAC,CAC/C,CAEF,OAAON,CACT,EC5JA,GAAM,CAAE,QAAAa,CAAQ,EAAI,MACd,CAAE,eAAAC,GAAgB,yBAAAC,EAAyB,EAAI,OAI9C,IAAMC,GAAgB,6BAEhBC,EAAQ,CAAC,EAETC,EAAW,IAAM,SAAS,YAAY,EAUtCC,EAAM,CAACC,EAAKC,EAAKC,KAC5BF,EAAI,IAAIC,EAAKC,CAAK,EACXA,GASIC,GAAM,CAACC,EAAKC,IAAS,CAChC,IAAIC,EACJ,GAAKA,EAAOC,GAAyBH,EAAKC,CAAI,QACxC,CAACC,IAASF,EAAMI,GAAeJ,CAAG,IACxC,OAAOE,CACT,EAQaG,GAAO,CAACC,EAASC,IAASA,EAAK,YAAYC,GAAiBF,CAAO,EAC1EE,GAAkB,CAACC,EAAMC,IAAMD,EAAK,WAAWC,CAAC,EC5CtD,GAAM,CAAC,eAAAC,EAAc,EAAI,OAYlBC,GAAQC,GAAS,CACtB,SAASC,EAAOC,EAAQ,CACtB,OAAOJ,GAAeI,EAAQ,WAAW,SAAS,CACpD,CACA,OAAAD,EAAO,UAAYD,EAAM,UAClBC,CACT,EChBA,IAAIE,EAOGC,EAAQ,CAACC,EAAYC,EAAWC,KAChCJ,IAAOA,EAAQK,EAAS,GAEzBD,EACFJ,EAAM,cAAcE,CAAU,EAE9BF,EAAM,eAAeE,CAAU,EAEjCF,EAAM,YAAYG,CAAS,EAC3BH,EAAM,eAAe,EACdE,GCVT,IAAMI,GAAS,CAAC,CAAC,WAAAC,EAAY,UAAAC,CAAS,EAAGC,IAAaC,EAAKH,EAAYC,EAAWC,CAAQ,EAEtFE,GAAY,GAOHC,EAAe,CAACC,EAAMC,IACjCH,IAAaE,EAAK,WAAa,GAC3B,EAAIC,EAAa,EAChBA,EAAYR,GAAOO,EAAM,EAAI,EAAIA,EAAK,UACtCC,EAAYD,EAAK,QAAQ,EAAIA,EAAK,WACrCA,EAGEE,GAAUC,GAAS,SAAS,cAAcA,CAAK,EA1BrDC,EAAAC,EAAAC,EA6BaC,EAAN,cAAiCC,GAAO,gBAAgB,CAAE,CAI/D,YAAYC,EAAU,CACpB,MAAMA,CAAQ,EAJhBC,EAAA,KAAAN,EAAcF,GAAQ,IAAI,GAC1BQ,EAAA,KAAAL,EAAaH,GAAQ,KAAK,GAC1BQ,EAAA,KAAAJ,EAASK,GAGP,KAAK,gBACHC,EAAA,KAAKR,GACL,GAAGK,EAAS,WACZG,EAAA,KAAKP,EACN,EACDP,GAAY,EACd,CACA,IAAI,YAAa,CAAE,OAAOc,EAAA,KAAKR,EAAa,CAC5C,IAAI,WAAY,CAAE,OAAOQ,EAAA,KAAKP,EAAY,CAC1C,IAAI,YAAa,CAAE,OAAOO,EAAA,KAAKR,GAAY,UAAY,CACvD,QAAS,CACPX,GAAO,KAAM,EAAK,CACpB,CACA,YAAYO,EAAM,CAChBP,GAAO,KAAM,EAAI,EAAE,YAAYO,CAAI,CACrC,CACA,SAAU,CACR,GAAM,CAAE,WAAAa,CAAW,EAAI,KACvB,GAAIA,IAAe,KACbD,EAAA,KAAKN,KAAWK,GAClBG,GAAA,KAAKR,EAAS,CAAC,GAAG,KAAK,UAAU,OAEhC,CASH,GAAIO,EAAY,CACd,GAAI,CAAE,WAAAnB,EAAY,UAAAC,CAAU,EAAI,KAEhC,IADAmB,GAAA,KAAKR,EAAS,CAACZ,CAAU,GAClBA,IAAeC,GACpBiB,EAAA,KAAKN,GAAO,KAAMZ,EAAaA,EAAW,WAAY,CAC1D,CAEA,KAAK,gBAAgB,GAAGkB,EAAA,KAAKN,EAAM,CACrC,CACA,OAAO,IACT,CACF,EA/CEF,EAAA,YACAC,EAAA,YACAC,EAAA,YC3BF,IAAMS,GAAe,CAACC,EAASC,EAAMC,IACnCF,EAAQ,aAAaC,EAAMC,CAAK,EAOrBC,EAAkB,CAACH,EAASC,IACvCD,EAAQ,gBAAgBC,CAAI,EAQjBG,GAAO,CAACJ,EAASE,IAAU,CACtC,QAAWG,KAAOH,EAAO,CACvB,IAAMI,EAAIJ,EAAMG,CAAG,EACbJ,EAAOI,IAAQ,OAASA,EAAM,QAAQA,CAAG,GAC3CC,GAAK,KAAMH,EAAgBH,EAASC,CAAI,EACvCF,GAAaC,EAASC,EAAMK,CAAC,CACpC,CACA,OAAOJ,CACT,EAEIK,EASSC,GAAK,CAACR,EAASE,EAAOD,IAAS,CAC1CA,EAAOA,EAAK,MAAM,CAAC,EACdM,IAAWA,EAAY,IAAI,SAChC,IAAME,EAAQF,EAAU,IAAIP,CAAO,GAAKU,EAAIH,EAAWP,EAAS,CAAC,CAAC,EAC9DW,EAAUF,EAAMR,CAAI,EACxB,OAAIU,GAAWA,EAAQ,CAAC,GAAGX,EAAQ,oBAAoBC,EAAM,GAAGU,CAAO,EACvEA,EAAUC,EAAQV,CAAK,EAAIA,EAAQ,CAACA,EAAO,EAAK,EAChDO,EAAMR,CAAI,EAAIU,EACVA,EAAQ,CAAC,GAAGX,EAAQ,iBAAiBC,EAAM,GAAGU,CAAO,EAClDT,CACT,EAWO,IAAMW,EAAO,CAACC,EAAQC,IAAU,CACrC,GAAM,CAAE,EAAGC,EAAM,EAAGH,CAAK,EAAIC,EACzBG,EAAU,GACd,OAAQ,OAAOF,EAAO,CACpB,IAAK,SACH,GAAIA,IAAU,KAAM,EACjBF,GAAQG,GAAM,YAAaF,EAAO,EAAIC,EAAM,QAAQ,CAAE,EACvD,KACF,CACF,IAAK,YACHE,EAAU,GACZ,QACED,EAAK,KAAOC,EAAU,GAAKF,EACvBF,IACFC,EAAO,EAAI,KACXD,EAAK,YAAYG,CAAI,GAEvB,KACJ,CACA,OAAOD,CACT,EAQaG,GAAY,CAACC,EAASJ,IAAUK,GAC3CD,EAASJ,EAAOA,GAAS,KAAO,QAAU,WAC5C,EAQaM,GAAO,CAACF,EAASJ,IAAU,CACtC,GAAM,CAAE,QAAAO,CAAQ,EAAIH,EACpB,QAAWI,KAAOR,EACZA,EAAMQ,CAAG,GAAK,KAAM,OAAOD,EAAQC,CAAG,EACrCD,EAAQC,CAAG,EAAIR,EAAMQ,CAAG,EAE/B,OAAOR,CACT,EASaS,EAAS,CAACC,EAAKV,EAAOW,IAAUD,EAAIC,CAAI,EAAIX,EAS5CY,GAAM,CAACR,EAASJ,EAAOW,IAASF,EAAOL,EAASJ,EAAOW,EAAK,MAAM,CAAC,CAAC,EASpEN,GAAc,CAACD,EAASJ,EAAOW,IAC1CX,GAAS,MACNa,EAAgBT,EAASO,CAAI,EAAGX,GACjCS,EAAOL,EAASJ,EAAOW,CAAI,EASlBD,GAAM,CAACN,EAASJ,KAC1B,OAAOA,GAAU,WAChBA,EAAMI,CAAO,EAAKJ,EAAM,QAAUI,EACpCJ,GAUIc,GAAU,CAACV,EAASJ,EAAOW,KAC9BX,GAAS,KACRa,EAAgBT,EAASO,CAAI,EAC7BI,GAAaX,EAASO,EAAMX,CAAK,EACnCA,GASWgB,GAAQ,CAACZ,EAASJ,IAC7BA,GAAS,KACPK,GAAYD,EAASJ,EAAO,OAAO,EACnCS,EAAOL,EAAQ,MAAOJ,EAAO,SAAS,EAU7BiB,GAAS,CAACb,EAASJ,EAAOW,KACrCP,EAAQ,gBAAgBO,EAAK,MAAM,CAAC,EAAGX,CAAK,EAC5CA,GAUWkB,EAAQ,CAACjB,EAAMD,EAAOmB,IAAS,CAE1C,GAAM,CAAE,OAAAC,CAAO,EAAIpB,EAEnB,GADAC,EAAK,KAAO,IAAImB,CAAM,IAClBA,EACF,OAAOC,GAASpB,EAAK,WAAYkB,EAAMnB,EAAOsB,EAAcrB,CAAI,EAElE,OAAQkB,EAAK,OAAQ,CACnB,IAAK,GACHA,EAAK,CAAC,EAAE,OAAO,EACjB,IAAK,GACH,MACF,QACEI,EACED,EAAaH,EAAK,CAAC,EAAG,CAAC,EACvBG,EAAaH,EAAK,GAAG,EAAE,EAAG,EAAE,EAC5B,EACF,EACA,KACJ,CAEA,OAAOK,CACT,EAEaC,GAAO,IAAI,IAAI,CAC1B,CAAC,OAAQC,EAAI,EACb,CAAC,QAASvB,EAAS,EACnB,CAAC,OAAQG,EAAI,EACb,CAAC,MAAOI,EAAG,EACX,CAAC,QAASM,EAAK,CACjB,CAAC,EAQYW,GAAY,CAACvB,EAASO,EAAMiB,IAAQ,CA3OjD,IAAAC,EA4OE,OAAQlB,EAAK,CAAC,EAAG,CACf,IAAK,IAAK,OAAOC,GACjB,IAAK,IAAK,OAAOK,GACjB,IAAK,IAAK,OAAOa,GACjB,QAAS,OACPF,GAAQ,oBAAqBxB,EAC1BO,IAAS,MAAQD,GAAMI,GACvBW,GAAK,IAAId,CAAI,IACZA,KAAQP,EACLO,EAAK,WAAW,IAAI,EACnBF,GACCoB,EAAAE,GAAI3B,EAASO,CAAI,IAAjB,MAAAkB,EAAoB,IAAMxB,GAAcS,GAE3CA,GAIV,CACF,EAQakB,GAAO,CAAC5B,EAASJ,KAC3BI,EAAQ,YAAcJ,GAAS,KAAO,GAAKA,EAC5CA,GC9PK,IAAMiC,EAAM,CAACC,EAAGC,EAAGC,KAAO,CAAE,EAAAF,EAAG,EAAAC,EAAG,EAAAC,CAAE,GAE9BC,GAAK,CAACF,EAAGC,KAAO,CAAE,EAAAD,EAAG,EAAAC,CAAE,GAcvBE,GAAS,CAACC,EAAG,EAAGC,EAAGJ,KAAO,CAAE,EAAGK,EAAO,EAAAF,EAAG,EAAG,EAAAC,EAAG,EAAAJ,CAAE,GAmBjDM,EAAQ,IAAMT,EAAI,KAAM,KAAMQ,CAAK,ECtChD,IAAOE,GAAQC,GAMb,CAACC,EAAUC,IAAW,CACpB,GAAM,CAAE,EAAGC,EAAU,EAAGC,EAAS,EAAGC,CAAO,EAAIL,EAAMC,EAAUC,CAAM,EAC/DI,EAAO,SAAS,WAAWH,EAAU,EAAI,EAE3CI,EAAUC,EACd,GAAIJ,IAAYI,EAAO,CACrBD,EAAU,CAAC,EACX,QAASE,EAASC,EAAMC,EAAI,EAAGA,EAAIP,EAAQ,OAAQO,IAAK,CACtD,GAAM,CAAE,EAAGC,EAAM,EAAGC,EAAQ,EAAGC,CAAK,EAAIV,EAAQO,CAAC,EAC3CI,EAAOH,IAASF,EAAOD,EAAWA,EAAUO,GAAKV,EAAOI,EAAOE,CAAK,EAC1EL,EAAQI,CAAC,EAAIM,GACXJ,EACAE,EACAD,EACAD,IAAWK,EAAQ,CAAC,EAAKL,IAAWM,EAAOC,EAAM,EAAI,IACvD,CACF,CACF,CACA,OAAOC,GACLhB,EAASC,EAAK,WAAa,IAAIgB,EAAmBhB,CAAI,EACtDC,CACF,CACF,ECnCK,IAAMgB,GAAgB,mDAChBC,GAAgB,8FCC7B,IAAMC,GAAW,iDACXC,GAAa,oCACbC,GAAQ,cAaPC,GAAQ,CAACC,EAAUC,EAAQC,IAAQ,CACxC,IAAIC,EAAI,EACR,OAAOH,EACJ,KAAK,GAAM,EACX,KAAK,EACL,QACCJ,GACA,CAACQ,EAAGC,EAAMC,EAAOC,IAAgB,IAAKF,CAAK,GAAIC,EAAM,QAAQT,GAAY,QAAW,EAAE,QAAQ,CAAE,GAAIU,EAAiBL,GAAOM,GAAc,KAAKH,CAAI,EAAK,KAAM,MAAMA,CAAI,GAAM,EAAG,GACnL,EACC,QACCP,GACAW,GAAQA,IAAS,IAAS,OAAOR,EAASE,GAAG,MAASF,EAASE,GACjE,CAEJ,EC7BA,IAAIO,GAAW,SAAS,cAAc,UAAU,EAAGC,GAAKC,GAOjDC,GAAQ,CAACC,EAAMC,IAAQ,CAC5B,GAAIA,EACF,OAAKJ,KACHA,GAAM,SAAS,gBAAgBK,GAAe,KAAK,EACnDJ,GAAQK,EAAS,EACjBL,GAAM,mBAAmBD,EAAG,GAEvBC,GAAM,yBAAyBE,CAAI,EAE5CJ,GAAS,UAAYI,EACrB,GAAM,CAAE,QAAAI,CAAQ,EAAIR,GACpB,OAAAA,GAAWA,GAAS,UAAU,EAAK,EAC5BQ,CACT,ECCA,IAAMC,GAAaC,GAAQ,CACzB,IAAMC,EAAO,CAAC,EACVC,EACJ,KAAQA,EAAaF,EAAK,YACxBC,EAAK,KAAKA,EAAK,QAAQ,KAAKC,EAAW,WAAYF,CAAI,CAAC,EACxDA,EAAOE,EAET,OAAOD,CACT,EAEME,GAAW,IAAM,SAAS,eAAe,EAAE,EAO3CC,GAAU,CAACC,EAAUC,EAAQC,IAAQ,CACzC,IAAMC,EAAUC,GAAcC,GAAOL,EAAUM,EAAQJ,CAAG,EAAGA,CAAG,EAC1D,CAAE,OAAAK,CAAO,EAAIP,EACfQ,EAAUC,EACd,GAAIF,EAAS,EAAG,CACd,IAAMG,EAAU,CAAC,EACXC,EAAK,SAAS,iBAAiBR,EAAS,GAAO,EACjDS,EAAI,EAAGC,EAAS,GAAGP,CAAM,GAAGM,GAAG,GAEnC,IADAJ,EAAU,CAAC,EACJI,EAAIL,GAAQ,CACjB,IAAMZ,EAAOgB,EAAG,SAAS,EAEzB,GAAIhB,EAAK,WAAa,GACpB,GAAIA,EAAK,OAASkB,EAAQ,CAExB,IAAMC,EAASC,EAAQd,EAAOW,EAAI,CAAC,CAAC,EAAII,EAAQC,EAC5CH,IAAWG,GAAMP,EAAQ,KAAKf,CAAI,EACtCa,EAAQ,KAAKU,EAAIxB,GAAWC,CAAI,EAAGmB,EAAQ,IAAI,CAAC,EAChDD,EAAS,GAAGP,CAAM,GAAGM,GAAG,EAC1B,MAEG,CACH,IAAIhB,EAEJ,KAAOD,EAAK,aAAakB,CAAM,GAAG,CAC3BjB,IAAMA,EAAOF,GAAWC,CAAI,GACjC,IAAMwB,EAAOxB,EAAK,aAAakB,CAAM,EACrCL,EAAQ,KAAKU,EAAItB,EAAMwB,GAAUzB,EAAMwB,EAAMjB,CAAG,EAAGiB,CAAI,CAAC,EACxDE,EAAgB1B,EAAMkB,CAAM,EAC5BA,EAAS,GAAGP,CAAM,GAAGM,GAAG,EAC1B,CAGE,CAACV,GACDoB,GAAc,KAAK3B,EAAK,SAAS,GACjCA,EAAK,YAAY,KAAK,IAAM,OAAOkB,CAAM,QAEzCL,EAAQ,KAAKU,EAAItB,GAAQF,GAAWC,CAAI,EAAG4B,GAAM,IAAI,CAAC,EACtDV,EAAS,GAAGP,CAAM,GAAGM,GAAG,GAE5B,CACF,CAEA,IAAKA,EAAI,EAAGA,EAAIF,EAAQ,OAAQE,IAC9BF,EAAQE,CAAC,EAAE,YAAYd,GAAS,CAAC,CACrC,CAGA,GAAM,CAAE,WAAA0B,CAAW,EAAIrB,EACnB,CAAE,OAAQsB,CAAI,EAAID,EAItB,OAAIC,EAAM,GACRA,EAAM,EACNtB,EAAQ,YAAYL,GAAS,CAAC,GAI9B2B,IAAQ,GAGRlB,IAAW,GACXiB,EAAW,CAAC,EAAE,WAAa,IAG3BC,EAAM,GAGDC,EAAIC,GAAO3B,EAAUkB,EAAIf,EAASK,EAASiB,IAAQ,CAAC,CAAC,CAC9D,EAGME,GAAQ,IAAI,QACZrB,EAAS,SAMRsB,GAAQ1B,GAAO,CAACF,EAAUC,IAAW0B,GAAM,IAAI3B,CAAQ,GAAKD,GAAQC,EAAUC,EAAQC,CAAG,ECnHhG,IAAM2B,GAAaC,GAAOC,GAAO,EAAK,CAAC,EACjCC,GAAYF,GAAOC,GAAO,EAAI,CAAC,EAO/BE,GAAS,CAACC,EAAM,CAAE,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAE,IAAM,CACpC,GAAIH,EAAK,IAAME,EAAG,CAChB,GAAM,CAAE,EAAAE,EAAG,EAAAC,CAAE,GAAKJ,EAAIH,GAAYH,IAAYO,EAAGC,CAAC,EAClDH,EAAK,EAAIE,EACTF,EAAK,EAAII,EACTJ,EAAK,EAAIK,CACX,CACA,OAAS,CAAE,EAAAA,CAAE,EAAIL,EAAM,EAAI,EAAG,EAAIK,EAAE,OAAQ,IAAK,CAC/C,IAAMC,EAAQH,EAAE,CAAC,EACXI,EAASF,EAAE,CAAC,EAClB,OAAQE,EAAO,EAAG,CAChB,KAAKC,EACHD,EAAO,EAAIC,EACTD,EAAO,EACPE,GAAaF,EAAO,EAAGD,CAAK,EAC5BC,EAAO,CACT,EACA,MACF,KAAKG,EACH,IAAMC,EAAUL,aAAiBM,EAC/Bb,GAAOQ,EAAO,IAAMA,EAAO,EAAIM,EAAM,GAAIP,CAAK,GAC7CC,EAAO,EAAI,KAAMD,GAEhBK,IAAYJ,EAAO,IACrBA,EAAO,EAAIG,EAAKH,EAAQI,CAAO,GACjC,MACF,QACML,IAAUC,EAAO,IACnBA,EAAO,EAAIA,EAAO,EAAEA,EAAO,EAAGD,EAAOC,EAAO,EAAGA,EAAO,CAAC,GACzD,KACJ,CACF,CACA,OAAOP,EAAK,CACd,EAOMS,GAAe,CAACK,EAAOC,IAAW,CACtC,IAAIC,EAAI,EAAG,CAAE,OAAAC,CAAO,EAAIF,EAExB,IADIE,EAASH,EAAM,QAAQA,EAAM,OAAOG,CAAM,EACvCD,EAAIC,EAAQD,IAAK,CACtB,IAAMV,EAAQS,EAAOC,CAAC,EAClBV,aAAiBM,EACnBG,EAAOC,CAAC,EAAIjB,GAAOe,EAAME,CAAC,IAAMF,EAAME,CAAC,EAAIH,EAAM,GAAIP,CAAK,EACvDQ,EAAME,CAAC,EAAI,IAClB,CACA,OAAOD,CACT,EASaH,EAAN,KAAW,CAChB,YAAYM,EAAKC,EAAUJ,EAAQ,CACjC,KAAK,EAAIG,EACT,KAAK,EAAIC,EACT,KAAK,EAAIJ,CACX,CACA,MAAMf,EAAOa,EAAM,EAAG,CACpB,OAAOd,GAAOC,EAAM,IAAI,CAC1B,CACF,ECzEA,IAAMoB,GAAMC,GAAO,CAACC,KAAaC,IAAW,IAAIC,EAAKH,EAAKC,EAAUC,CAAM,EAG7DE,GAAOL,GAAI,EAAK,EAGhBC,GAAMD,GAAI,EAAI,ECT3B,IAAMM,GAAQ,IAAI,QAUXC,GAAQ,CAACC,EAAOC,EAAMC,IAAU,CACrC,IAAMC,EAAOL,GAAM,IAAIE,CAAK,GAAKI,EAAIN,GAAOE,EAAOK,EAAM,CAAC,EACpD,CAAE,EAAAC,CAAE,EAAIH,EACRI,EAAQL,GAAS,OAAOD,GAAS,WAAcA,EAAK,EAAIA,EACxDO,EAAOD,aAAgBE,EAAOF,EAAK,MAAMJ,CAAI,EAAII,EACvD,OAAID,IAAME,GACRR,EAAM,iBAAiBG,EAAK,EAAIK,GAAM,QAAQ,CAAC,EAC1CR,CACT,ECDA,IAAMU,GAAQ,IAAI,QACZC,GAAYC,GAA4B,CAACC,EAAKC,IAAQ,CAE1D,SAASC,EAAIC,KAAaC,EAAQ,CAChC,OAAO,IAAIC,EAAKN,EAAKI,EAAUC,CAAM,EAAE,MAAM,IAAI,CACnD,CAEA,IAAME,EAAOT,GAAM,IAAIG,CAAG,GAAKO,EAAIV,GAAOG,EAAK,IAAI,GAAG,EACtD,OAAOM,EAAK,IAAIL,CAAG,GAAKM,EAAID,EAAML,EAAKC,EAAI,KAAKM,EAAM,CAAC,CAAC,CAC1D,EAGaC,GAAUX,GAAU,EAAK,EAGzBY,GAASZ,GAAU,EAAI,ECnCpC,IAAMa,GAAW,IAAI,qBACnB,CAAC,CAACC,EAAoBC,EAAMC,CAAK,IAAM,CAEjCA,GAAO,QAAQ,MAAM,KAAK,OAAOD,CAAI,CAAC,GAAI,mBAAoB,WAAW,EAC7ED,EAAmBC,CAAI,CACzB,CACF,EAEME,GAAc,OAAO,OAAO,IAAI,EAiBzBC,GAAS,CACpBC,EACAL,EACA,CAAE,MAAAE,EAAO,QAAAI,EAAS,OAAQC,EAAG,MAAAC,EAAQH,CAAK,EAAIF,KAC3C,CAIH,IAAMM,EAASF,GAAK,IAAI,MAAMF,EAAMC,GAAWH,EAAW,EACpDO,EAAO,CAACD,EAAQ,CAACT,EAAoBK,EAAM,CAAC,CAACH,CAAK,CAAC,EACzD,OAAIM,IAAU,IAAOE,EAAK,KAAKF,CAAK,EAGpCT,GAAS,SAAS,GAAGW,CAAI,EAClBD,CACT,EAOaE,GAAOH,GAAST,GAAS,WAAWS,CAAK,EC1CtD,IAAMI,GAAU,IAAI,QAMdC,GAAOC,GAAWA,EAAQ,EAE5BC,GAAS,GAMAC,GAASC,GAUb,CAACC,EAAOC,IAAS,CAItB,GAHAJ,GAAS,OAAOI,GAAS,WACzBC,GAAOF,CAAK,EAERH,GAAQ,OAAOM,GAAOH,EAAOC,EAAM,EAAK,EAC5CJ,GAAS,GAET,IAAMO,EAAK,IAAI,QAAQJ,CAAK,EACtBJ,EAAUG,EAAO,IAAM,CAAEI,GAAOC,EAAG,MAAM,EAAGH,EAAK,EAAG,EAAK,CAAE,CAAC,EAClE,OAAAP,GAAQ,IAAIM,EAAOJ,CAAO,EACnBS,GAAOT,EAASD,GAAM,CAAE,OAAQK,CAAM,CAAC,CAChD,EAOWE,GAASF,GAAS,CAC7B,IAAMJ,EAAUF,GAAQ,IAAIM,CAAK,EAC7BJ,IACEC,IAAQH,GAAQ,OAAOM,CAAK,EAChCM,GAAKV,CAAO,EACZA,EAAQ,EAEZ,ECtDA,IAAMW,GAAeC,OAAAA,IAAW,gBAAA,EAsChC,SAASC,IAAAA,CACR,GAAIC,EAAa,EAChBA,QADD,CAQA,QAHIC,EACAC,EAAAA,GAEGC,IAAP,QAAoC,CACnC,IAAIC,EAA6BD,EAKjC,IAJAA,EAAAA,OAEAE,KAEOD,IAAP,QAA6B,CAC5B,IAAME,EAA2BF,EAAOG,EAIxC,GAHAH,EAAOG,EAAAA,OACPH,EAAOI,GAAAA,GAEP,EApDc,EAoDRJ,EAAOI,IAAsBC,GAAiBL,CAAAA,EACnD,GAAA,CACCA,EAAOM,EAAAA,CAMP,OALQC,EAAAA,CACHT,IACJD,EAAQU,EACRT,EAAAA,GAED,CAEFE,EAASE,CACT,CACD,CAID,GAHAD,GAAiB,EACjBL,IAEIE,EACH,MAAMD,CAjCN,CAmCF,CA2BA,IAAIW,EAAAA,OAoBJ,IAAIC,EAAAA,OACAC,EAAa,EACbC,GAAiB,EAIjBC,GAAgB,EAEpB,SAASC,GAAcC,EAAAA,CACtB,GAAIC,IAAJ,OAAA,CAIA,IAAIC,EAAOF,EAAOG,EAClB,GAAID,IAAJ,QAA0BA,EAAKE,IAAYH,EAa1CC,SAAO,CACNG,EAAU,EACVC,EAASN,EACTO,EAAaN,EAAYO,EACzBC,EAAAA,OACAL,EAASH,EACTS,EAAAA,OACAC,EAAAA,OACAC,EAAeV,CAAAA,EAGZD,EAAYO,IAAhB,SACCP,EAAYO,EAASC,EAAcP,GAEpCD,EAAYO,EAAWN,EACvBF,EAAOG,EAAQD,EA9JA,GAkKXD,EAAYY,GACfb,EAAOc,EAAWZ,CAAAA,EAEZA,EACGA,GAAAA,EAAKG,IAALH,GAEVA,SAAKG,EAAW,EAeZH,EAAKO,IAAT,SACCP,EAAKO,EAAYF,EAAcL,EAAKK,EAEhCL,EAAKK,IAAT,SACCL,EAAKK,EAAYE,EAAcP,EAAKO,GAGrCP,EAAKK,EAAcN,EAAYO,EAC/BN,EAAKO,EAAAA,OAELR,EAAYO,EAAUC,EAAcP,EACpCD,EAAYO,EAAWN,GAKjBA,CAxEP,CA2EF,CAgEA,SAASa,EAAqBC,EAAAA,CAC7BC,KAAKC,EAASF,EACdC,KAAKZ,EAAW,EAChBY,KAAKd,EAAAA,OACLc,KAAKE,EAAAA,MACN,CAEAJ,EAAOK,UAAUC,MAAQC,GAEzBP,EAAOK,UAAUG,EAAW,UAAA,CAC3B,MAAA,EACD,EAEAR,EAAOK,UAAUN,EAAa,SAAUZ,EAAAA,CACnCe,KAAKE,IAAajB,GAAQA,EAAKQ,IAAbR,SACrBA,EAAKS,EAAcM,KAAKE,EACpBF,KAAKE,IAAT,SACCF,KAAKE,EAAST,EAAcR,GAE7Be,KAAKE,EAAWjB,EAElB,EAEAa,EAAOK,UAAUI,EAAe,SAAUtB,EAAAA,CAEzC,GAAIe,KAAKE,IAAT,OAAiC,CAChC,IAAMM,EAAOvB,EAAKQ,EACZgB,EAAOxB,EAAKS,EACdc,IAAJ,SACCA,EAAKd,EAAce,EACnBxB,EAAKQ,EAAAA,QAEFgB,IAAJ,SACCA,EAAKhB,EAAce,EACnBvB,EAAKS,EAAAA,QAEFT,IAASe,KAAKE,IACjBF,KAAKE,EAAWO,EAEjB,CACF,EAEAX,EAAOK,UAAUO,UAAY,SAAUC,EAAAA,CAAEC,IAAAA,EACxCZ,KAAA,OAAOa,EAAO,UAAA,CACb,IAAMd,EAAQa,EAAKb,MAEbe,EAAc9B,EACpBA,EAAAA,OACA,GAAA,CACC2B,EAAGZ,CAAAA,CAGH,QAFA,CACAf,EAAc8B,CACd,CACF,CAAA,CACD,EAEAhB,EAAOK,UAAUY,QAAU,UAAA,CAC1B,OAAOf,KAAKD,KACb,EAEAD,EAAOK,UAAUa,SAAW,UAAA,CAC3B,OAAA,KAAYjB,MAAQ,EACrB,EAEAD,EAAOK,UAAUc,OAAS,UAAA,CACzB,OAAWjB,KAACD,KACb,EAEAD,EAAOK,UAAUe,KAAO,UAAA,CACvB,IAAMJ,EAAc9B,EACpBA,EAAAA,OACA,GAAA,CACC,OAAOgB,KAAKD,KAGZ,QAFA,CACAf,EAAc8B,CACd,CACF,EAEAK,OAAOC,eAAetB,EAAOK,UAAW,QAAS,CAChDkB,IAAGA,UAAAA,CACF,IAAMpC,EAAOH,GAAckB,IAAAA,EAC3B,OAAIf,IAAJ,SACCA,EAAKG,EAAWY,KAAKZ,GAEXY,KAACC,CACb,EACAqB,IAAAA,SAAkBvB,EAAAA,CACjB,GAAIA,IAAUC,KAAKC,EAAQ,CAC1B,GAAIrB,GAAiB,IACpB,MAAM,IAAI2C,MAAM,gBAAA,EAGjBvB,KAAKC,EAASF,EACdC,KAAKZ,IACLP,KA7UFF,IAgVE,GAAA,CACC,QACKM,EAAOe,KAAKE,EAChBjB,IADgBiB,OAEhBjB,EAAOA,EAAKS,EAEZT,EAAKE,EAAQqC,EAAAA,CAId,QAFA,CACAC,GAAAA,CACA,CACD,CACF,CAAA,CAAA,EAWK,SAAU1C,GAAUgB,EAAAA,CACzB,OAAW,IAAAD,EAAOC,CAAAA,CACnB,CAEA,SAAS2B,GAAiBC,EAAAA,CAIzB,QACK1C,EAAO0C,EAAOpC,EAClBN,IADkBM,OAElBN,EAAOA,EAAKO,EAKZ,GACCP,EAAKI,EAAQD,IAAaH,EAAKG,GAAAA,CAC9BH,EAAKI,EAAQiB,EAAAA,GACdrB,EAAKI,EAAQD,IAAaH,EAAKG,EAE/B,MAAA,GAKF,MAAA,EACD,CAEA,SAASwC,GAAeD,EAAAA,CAavB,QACK1C,EAAO0C,EAAOpC,EAClBN,IADkBM,OAElBN,EAAOA,EAAKO,EACX,CACD,IAAMqC,EAAe5C,EAAKI,EAAQH,EAOlC,GANI2C,IAAJ,SACC5C,EAAKU,EAAgBkC,GAEtB5C,EAAKI,EAAQH,EAAQD,EACrBA,EAAKG,EAAAA,GAEDH,EAAKO,IAAT,OAAoC,CACnCmC,EAAOpC,EAAWN,EAClB,KACA,CACD,CACF,CAEA,SAAS6C,GAAeH,EAAAA,CASvB,QARI1C,EAAO0C,EAAOpC,EACdwC,EAAAA,OAOG9C,IAAP,QAA2B,CAC1B,IAAMuB,EAAOvB,EAAKK,EAUdL,EAAKG,IAAT,IACCH,EAAKI,EAAQkB,EAAatB,CAAAA,EAEtBuB,IAAJ,SACCA,EAAKhB,EAAcP,EAAKO,GAErBP,EAAKO,IAAT,SACCP,EAAKO,EAAYF,EAAckB,IAahCuB,EAAO9C,EAGRA,EAAKI,EAAQH,EAAQD,EAAKU,EACtBV,EAAKU,IAAT,SACCV,EAAKU,EAAAA,QAGNV,EAAOuB,CACP,CAEDmB,EAAOpC,EAAWwC,CACnB,CAcA,SAASC,EAAyBrB,EAAAA,CACjCb,EAAOmC,KAAKjC,KAAAA,MAAMkC,EAElBlC,KAAKmC,EAAMxB,EACXX,KAAKT,EAAAA,OACLS,KAAKoC,EAAiBvD,GAAgB,EACtCmB,KAAKJ,EA1gBW,CA2gBjB,EAEAoC,EAAS7B,UAAY,IAAIL,GAENQ,EAAW,UAAA,CAG7B,GAFAN,KAAKJ,GAAAA,GAlhBU,EAohBXI,KAAKJ,EACR,MAAA,GAWD,IALoByC,GAAfrC,KAAKJ,IAthBM,KAyhBhBI,KAAKJ,GAAAA,GAEDI,KAAKoC,IAAmBvD,IAC3B,MAAA,GAOD,GALAmB,KAAKoC,EAAiBvD,GAItBmB,KAAKJ,GAviBU,EAwiBXI,KAAKZ,EAAW,GAAA,CAAMsC,GAAiB1B,IAAAA,EAC1CA,YAAKJ,GAAAA,GACL,GAGD,IAAMkB,EAAc9B,EACpB,GAAA,CACC4C,GAAe5B,IAAAA,EACfhB,EAAcgB,KACd,IAAMD,EAAQC,KAAKmC,EAAAA,GA7iBH,GA+iBfnC,KAAKJ,GACLI,KAAKC,IAAWF,GAChBC,KAAKZ,IAAa,KAElBY,KAAKC,EAASF,EACdC,KAAKJ,GAAAA,IACLI,KAAKZ,IAMN,OAJQkD,EAAAA,CACRtC,KAAKC,EAASqC,EACdtC,KAAKJ,GAzjBW,GA0jBhBI,KAAKZ,GACL,CACDJ,OAAAA,EAAc8B,EACdgB,GAAe9B,IAAAA,EACfA,KAAKJ,GAAAA,GACL,EACD,EAEAoC,EAAS7B,UAAUN,EAAa,SAAUZ,EAAAA,CACzC,GAAIe,KAAKE,IAAT,OAAiC,CAChCF,KAAKJ,GAAUyC,GAIf,QACKpD,EAAOe,KAAKT,EAChBN,IADgBM,OAEhBN,EAAOA,EAAKO,EAEZP,EAAKI,EAAQQ,EAAWZ,CAAAA,CAEzB,CACDa,EAAOK,UAAUN,EAAWoC,KAAKjC,KAAMf,CAAAA,CACxC,EAEA+C,EAAS7B,UAAUI,EAAe,SAAUtB,EAAAA,CAE3C,GAAIe,KAAKE,IAAT,SACCJ,EAAOK,UAAUI,EAAa0B,KAAKjC,KAAMf,CAAAA,EAIrCe,KAAKE,IAAT,QAAiC,CAChCF,KAAKJ,GAAAA,IAEL,QACKX,EAAOe,KAAKT,EAChBN,IADgBM,OAEhBN,EAAOA,EAAKO,EAEZP,EAAKI,EAAQkB,EAAatB,CAAAA,CAE3B,CAEH,EAEA+C,EAAS7B,UAAUqB,EAAU,UAAA,CAC5B,GAAA,EA5mBgB,EA4mBVxB,KAAKJ,GAAoB,CAC9BI,KAAKJ,GAAUyC,EAEf,QACKpD,EAAOe,KAAKE,EAChBjB,IADgBiB,OAEhBjB,EAAOA,EAAKS,EAEZT,EAAKE,EAAQqC,EAAAA,CAEd,CACF,EAEAL,OAAOC,eAAeY,EAAS7B,UAAW,QAAS,CAClDkB,IAAAA,UAAAA,CACC,GA5nBc,EA4nBVrB,KAAKJ,EACR,MAAM,IAAI2B,MAAM,gBAAA,EAEjB,IAAMtC,EAAOH,GAAckB,IAAAA,EAK3B,GAJAA,KAAKM,EAAAA,EACDrB,IAAJ,SACCA,EAAKG,EAAWY,KAAKZ,GA9nBN,GAgoBZY,KAAKJ,EACR,MAAMI,KAAKC,EAEZ,OAAOD,KAAKC,CACb,CAAA,CAAA,EA0BD,SAASsC,EAAY5B,EAAAA,CACpB,OAAW,IAAAqB,EAASrB,CAAAA,CACrB,CAEA,SAAS6B,GAAc3B,EAAAA,CACtB,IAAM4B,EAAU5B,EAAO6B,EAGvB,GAFA7B,EAAO6B,EAAAA,OAEgB,OAAZD,GAAY,WAAY,CA1oBnC9D,IA8oBC,IAAMmC,EAAc9B,EACpBA,EAAAA,OACA,GAAA,CACCyD,EAAAA,CASA,OARQH,EAAAA,CACRzB,MAAAA,EAAOjB,GAAAA,GACPiB,EAAOjB,GAjrBO,EAkrBd+C,GAAc9B,CAAAA,EACRyB,CACN,QAAA,CACAtD,EAAc8B,EACdW,GAAAA,CACA,CACD,CACF,CAEA,SAASkB,GAAc9B,EAAAA,CACtB,QACK5B,EAAO4B,EAAOtB,EAClBN,IADkBM,OAElBN,EAAOA,EAAKO,EAEZP,EAAKI,EAAQkB,EAAatB,CAAAA,EAE3B4B,EAAOsB,EAAAA,OACPtB,EAAOtB,EAAAA,OAEPiD,GAAc3B,CAAAA,CACf,CAEA,SAAS+B,GAAwB9B,EAAAA,CAChC,GAAI9B,IAAgBgB,KACnB,MAAA,IAAUuB,MAAM,qBAAA,EAEjBO,GAAe9B,IAAAA,EACfhB,EAAc8B,EAEdd,KAAKJ,GAAAA,GAhtBW,EAitBZI,KAAKJ,GACR+C,GAAc3C,IAAAA,EAEfyB,GAAAA,CACD,CAmBA,SAASoB,EAAqBlC,EAAAA,CAC7BX,KAAKmC,EAAMxB,EACXX,KAAK0C,EAAAA,OACL1C,KAAKT,EAAAA,OACLS,KAAK8C,EAAAA,OACL9C,KAAKJ,EA3uBW,EA4uBjB,CAEAiD,EAAO1C,UAAU4C,EAAY,UAAA,CAC5B,IAAMC,EAAShD,KAAKiD,EAAAA,EACpB,GAAA,CAEC,GApvBe,EAmvBXjD,KAAKJ,GACLI,KAAKmC,IAAT,OAA4B,OAE5B,IAAMM,EAAUzC,KAAKmC,EAAAA,EACE,OAAZM,GAAY,aACtBzC,KAAK0C,EAAWD,EAIjB,QAFA,CACAO,EAAAA,CACA,CACF,EAEAH,EAAO1C,UAAU8C,EAAS,UAAA,CACzB,GAnwBe,EAmwBXjD,KAAKJ,EACR,MAAA,IAAU2B,MAAM,gBAAA,EAEjBvB,KAAKJ,GAtwBU,EAuwBfI,KAAKJ,GAAAA,GACL4C,GAAcxC,IAAAA,EACd4B,GAAe5B,IAAAA,EAzuBfrB,IA4uBA,IAAMmC,EAAc9B,EACpBA,OAAAA,EAAcgB,KACP4C,GAAUM,KAAKlD,KAAMc,CAAAA,CAC7B,EAEA+B,EAAO1C,UAAUqB,EAAU,UAAA,CAhxBV,EAixBVxB,KAAKJ,IACVI,KAAKJ,GAlxBU,EAmxBfI,KAAK8C,EAAqBpE,EAC1BA,EAAgBsB,KAElB,EAEA6C,EAAO1C,UAAUgD,EAAW,UAAA,CAC3BnD,KAAKJ,GAvxBW,EAHD,EA4xBTI,KAAKJ,GACV+C,GAAc3C,IAAAA,CAEhB,EAeA,SAASa,EAAOF,EAAAA,CACf,IAAME,EAAS,IAAIgC,EAAOlC,CAAAA,EAC1B,GAAA,CACCE,EAAOkC,EAAAA,CAIP,OAHQT,EAAAA,CACRzB,QAAOsC,EAAAA,EACDb,CACN,CAGD,OAAOzB,EAAOsC,EAASD,KAAKrC,CAAAA,CAC7B,CC1zBO,IAAMuC,GAAN,cAAuBC,CAAU,CACpC,KAAKC,EAA6B,CAC9B,GAAI,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAO,KAAK,OAAU,SAAU,CAC/E,IAAMC,EAAeC,GAAU,KAAK,KAAK,EACzC,KAAK,MAAQ,CAAE,GAAGD,EAAc,GAAGD,CAAM,CAC7C,MACI,KAAK,MAAQA,CAErB,CACJ,EAEO,SAASG,EAAeC,EAA2B,CACtD,IAAMC,EAAaC,GAAaF,CAAY,EAC5C,cAAO,eAAeC,EAAYP,GAAM,SAAS,EAC1CO,CACX,CAGA,SAASH,GAAaK,EAAW,CAC7B,GAAIA,IAAQ,MAAQ,OAAOA,GAAQ,SAC/B,OAAOA,EAGX,GAAI,MAAM,QAAQA,CAAG,EACjB,OAAOA,EAAI,IAAIL,EAAS,EAG5B,IAAMM,EAAsC,CAAC,EAC7C,QAAWC,KAAO,QAAQ,QAAQF,CAAG,EACjCC,EAAUC,CAAuB,EAAIP,GAAWK,EAAiCE,CAAG,CAAC,EAGzF,OAAOD,CACX,CAIO,SAASE,GACZC,EACuB,CACvB,MAAO,IAAIC,IACQC,EAAe,IAAMF,EAAU,GAAGC,CAAI,CAAC,EACxC,KAEtB,CAGO,SAASE,GACZC,EACqB,CACrB,IAAMC,EAAkB,IAAI,IACtBC,EAAgB,IAAI,IAoC1B,OAlCiB,OAAO,QAAQF,EAAW,CAAC,EAAE,OAAO,CAACG,EAAK,CAACT,EAAKU,CAAE,IAC3DA,EAAG,SAAW,GAETH,EAAgB,IAAIP,CAAG,GACxBO,EAAgB,IAAIP,EAAKI,EAAe,IAAMM,EAAG,CAAC,CAAC,EAEhD,CACH,GAAGD,EACH,CAACT,CAAG,EAAG,IAAMO,EAAgB,IAAIP,CAAG,EAAE,KAC1C,GAIG,CACH,GAAGS,EACH,CAACT,CAAG,EAAG,IAAIG,IAAgB,CACvB,IAAMQ,EAAW,KAAK,UAAUR,CAAI,EAChCS,EAAWJ,EAAc,IAAIR,CAAG,EAOpC,GALKY,IACDA,EAAW,IAAI,IACfJ,EAAc,IAAIR,EAAKY,CAAQ,GAG/B,CAACA,EAAS,IAAID,CAAQ,EAAG,CACzB,IAAME,EAAST,EAAe,IAAMM,EAAG,GAAGP,CAAI,CAAC,EAC/CS,EAAS,IAAID,EAAUE,CAAM,CACjC,CAEA,OAAOD,EAAS,IAAID,CAAQ,EAAE,KAClC,CACJ,EACD,CAAC,CAA0B,CAGlC,CCpFO,IAAMG,EAAN,KAAsB,CAKzB,OAAe,eAAeC,EAAyB,CACnD,OAAOA,EAAK,IAAIC,GAAO,CACnB,GAAIA,IAAQ,KAAM,MAAO,OACzB,GAAIA,IAAQ,OAAW,MAAO,YAC9B,GAAI,OAAOA,GAAQ,SAAU,CAEzB,IAAMC,EAAMD,EACZ,MAAI,OAAQC,EAAY,OAAOA,EAAI,EAAE,EACjC,QAASA,EAAY,OAAOA,EAAI,GAAG,EAEhC,KAAK,UAAU,KAAK,eAAeA,CAAG,CAAC,CAClD,CACA,OAAO,OAAOD,CAAG,CACrB,CAAC,EAAE,KAAK,GAAG,CACf,CAEA,OAAe,eAAiCC,EAAW,CACvD,OAAI,MAAM,QAAQA,CAAG,EACVA,EAAI,IAAIC,GACX,OAAOA,GAAS,UAAYA,IAAS,KAAO,KAAK,eAAeA,CAAI,EAAIA,CAC5E,EAEG,OAAO,KAAKD,CAAG,EACjB,KAAK,EACL,OAAO,CAACE,EAAKC,IAAQ,CAClB,IAAMC,EAAQJ,EAAIG,CAAc,EAChC,OAACD,EAAYC,CAAG,EAAI,OAAOC,GAAU,UAAYA,IAAU,KACrD,KAAK,eAAeA,CAAK,EACzBA,EACCF,CACX,EAAG,CAAC,CAAM,CAClB,CAEA,OAAe,UAAUG,EAAcC,EAAuB,CAC1D,OAAID,EAAE,SAAWC,EAAE,OAAe,GAC3BD,EAAE,MAAM,CAACE,EAAKC,IACb,OAAO,GAAGD,EAAKD,EAAEE,CAAC,CAAC,EAAU,GAC7B,OAAOD,GAAQ,UAAYA,GAAO,OAAOD,EAAEE,CAAC,GAAM,UAAYF,EAAEE,CAAC,EAC1D,KAAK,UAAU,KAAK,eAAeD,CAAa,CAAC,IACpD,KAAK,UAAU,KAAK,eAAeD,EAAEE,CAAC,CAAW,CAAC,EAEnD,EACV,CACL,CAEA,OAAc,eACVC,EACAC,EAGI,CAAC,EACe,CAhE5B,IAAAC,EAAAC,EAiEQ,IAAMC,EAAQ,IAAI,IACZC,GAASH,EAAAD,EAAQ,SAAR,KAAAC,EAAkB,KAAK,aAChCI,GAAUH,EAAAF,EAAQ,YAAR,KAAAE,EAAqB,KAAK,aAE1C,MAAO,IAAId,IAAkB,CAEzB,GAAIA,EAAK,SAAW,EAAG,CACnB,GAAI,CAACe,EAAM,IAAI,GAAG,EAAG,CACjB,IAAMG,EAASC,EAAe,IAAMR,EAAG,GAAGX,CAAI,CAAC,EAC/Ce,EAAM,IAAI,IAAK,CACX,OAAAG,EACA,KAAM,CAAC,EACP,aAAc,KAAK,IAAI,CAC3B,CAAC,CACL,CACA,IAAME,EAASL,EAAM,IAAI,GAAG,EAC5B,OAAAK,EAAO,aAAe,KAAK,IAAI,EACxBA,EAAO,OAAO,KACzB,CAEA,IAAMC,EAAW,KAAK,eAAerB,CAAI,EACnCoB,EAASL,EAAM,IAAIM,CAAQ,EAGjC,GAAID,GAAU,KAAK,UAAUA,EAAO,KAAMpB,CAAI,EAAG,CAC7C,IAAMsB,EAAM,KAAK,IAAI,EACrB,GAAIA,EAAMF,EAAO,cAAgBJ,EAC7B,OAAAI,EAAO,aAAeE,EACfF,EAAO,OAAO,KAE7B,CAGIL,EAAM,MAAQE,EAAU,KAAK,kBAC7B,KAAK,QAAQF,EAAOC,CAAM,EAI9B,IAAME,EAASC,EAAe,IAAMR,EAAG,GAAGX,CAAI,CAAC,EAC/C,OAAAe,EAAM,IAAIM,EAAU,CAChB,OAAAH,EACA,KAAM,CAAC,GAAGlB,CAAI,EACd,aAAc,KAAK,IAAI,CAC3B,CAAC,EAEMkB,EAAO,KAClB,CACJ,CAEA,OAAe,QACXH,EACAC,EACI,CACJ,IAAMM,EAAM,KAAK,IAAI,EACrB,OAAW,CAACjB,EAAKC,CAAK,IAAKS,EAAM,QAAQ,EACjCO,EAAMhB,EAAM,aAAeU,GAC3BD,EAAM,OAAOV,CAAG,CAG5B,CACJ,EArHaN,EACM,aAAe,IADrBA,EAEM,iBAAmB,GAFzBA,EAGM,aAAe,EAAI,GAAK,IC6B3C,IAAMwB,GAAoC,CAAC,EAEpC,SAASC,GACZC,EACwB,CACxB,GAAM,CAAE,MAAOC,EAAc,QAASC,EAAW,SAAUC,EAAY,QAASC,CAAU,EAAIJ,EAExFK,EAAQC,EAAYL,CAAY,EAEhCM,EAAUL,EACV,OAAO,QAAQA,EAAU,CAAE,MAAAG,CAAM,CAAC,CAAC,EAAE,OAAO,CAACG,EAAK,CAACC,EAAKC,CAAE,KAAO,CAC/D,GAAGF,EACH,CAACC,CAAG,EAAGC,EAAG,CACd,GAAI,CAAC,CAAC,EACH,CAAC,EAGFC,EAAWR,EACX,OAAO,QAAQA,EAAW,CAAE,MAAAE,CAAM,CAAC,CAAC,EAAE,OAAO,CAACG,EAAK,CAACC,EAAKC,CAAE,IAAM,CAC/D,IAAME,EAAmBC,EAAgB,eACrC,IAAMH,EAAG,EACT,CACI,OAAQ,IACR,UAAW,GACf,CACJ,EAEA,MAAO,CACH,GAAGF,EACH,CAACC,CAAG,EAAG,CACH,IAAI,OAAQ,CACR,OAAOG,EAAiB,CAC5B,CACJ,CACJ,CACJ,EAAG,CAAC,CAAC,EACF,CAAC,EAEFE,EAAUV,EACTA,EAAU,CACT,MAAAC,EACA,SAAAM,CACJ,CAAC,EACE,CAAC,EAER,MAAO,CAAE,MAAAN,EAAO,QAAAE,EAAS,SAAAI,EAAU,QAAAG,CAAQ,CAC/C,CAEA,SAASC,GACLN,EACAO,EACI,CACJ,GAAIlB,GAAYW,CAAG,EACf,MAAM,IAAI,MAAM,UAAUA,CAAG,kBAAkB,EAEnDX,GAAYW,CAAG,EAAIO,CAEvB,CAEA,SAASC,GAAsCR,EAAwB,CACnE,IAAMO,EAAQlB,GAAYW,CAAG,EAC7B,GAAI,CAACO,EACD,MAAM,IAAI,MAAM,UAAUP,CAAG,aAAa,EAE9C,OAAOO,CACX,CAEO,SAASE,GAKdlB,EAMC,CACC,GAAM,CAAE,IAAAS,EAAK,MAAAJ,EAAO,GAAGc,CAAK,EAAInB,EAC1BgB,EAAQjB,GAAY,CAAE,MAAOM,EAAO,GAAGc,CAAK,CAAC,EACnD,OAAAC,EAAc,SAASX,EAAKO,CAAK,EAC1BA,CACX,CAEO,IAAMI,EAA+B,CACxC,KAAMtB,GACN,EAAGmB,GACH,SAAUF,EACd,ECcO,SAASM,GAMdC,EAA0C,CACxC,GAAM,CACF,QAAAC,EACA,MAAOC,EAAkB,CAAC,EAC1B,MAAOC,EACP,QAASC,EAAa,KAAO,CAAC,GAC9B,SAAUC,EAAc,KAAO,CAAC,GAChC,QAASC,EAAa,KAAO,CAAC,GAC9B,UAAAC,EACA,aAAAC,EACA,OAAAC,EACA,OAAAC,CACJ,EAAIV,EAEEW,EAAUC,GAASC,CAAM,EAE/B,MAAMC,UAAsB,WAAyC,CAajE,aAAc,CACV,MAAM,EARV,WAAgC,CAAC,EACjC,aAA0B,CAAC,EAQvB,KAAK,MAAQC,GAAO,CAAC,CAAkB,EACvC,KAAK,MAAM,MAAQ,KAAK,gBAAgB,EACxC,KAAK,MAAQC,EAAYb,CAAiB,EAC1C,KAAK,QAAU,KAAK,aAAa,EACjC,KAAK,SAAW,KAAK,cAAc,EACnC,KAAK,QAAU,KAAK,aAAa,CACrC,CAZA,WAAW,oBAAqB,CAC5B,OAAO,OAAO,KAAKD,CAAe,EAAE,IAAKe,GAAS,QAAQA,CAAI,EAAE,CACpE,CAYO,EAAWC,EAAa,CAC3B,OAAQ,KAAaA,CAAG,CAC5B,CAEO,UAAmBD,EAAcE,EAAY,CAAC,EAAc,CAC/D,KAAK,cAAc,IAAI,YAAYF,EAAM,CAAE,OAAAE,CAAO,CAAC,CAAC,CACxD,CAEA,cAAiD,CAC7C,IAAMC,EAAYhB,EAAU,CACxB,MAAO,KAAK,aAAa,EACzB,MAAO,KAAK,MACZ,MAAOiB,EACP,GAAI,KACJ,MAAO,KAAK,KAChB,CAAC,EAED,OAAO,OAAO,QAAQD,CAAS,EAAE,OAAO,CAACE,EAAK,CAACJ,EAAKK,CAAE,KAAO,CACzD,GAAGD,EACH,CAACJ,CAAG,EAAGK,EAAG,CACd,GAAI,CAAC,CAAC,CACV,CAEA,eAAmD,CAC/C,IAAMC,EAAU,CACZ,MAAO,KAAK,aAAa,EACzB,MAAO,KAAK,MACZ,MAAOH,EACP,GAAI,KACJ,MAAO,KAAK,KAChB,EAEMI,EAAcpB,EAAWmB,CAAO,EAChCE,EAAW,CAAC,EAGlB,OAAW,CAACR,EAAKK,CAAE,IAAK,OAAO,QAAQE,CAAW,EAAG,CACjD,IAAME,EAAmBC,EAAgB,eACrC,IAAML,EAAG,EACT,CACI,OAAQ,IACR,UAAW,GACf,CACJ,EAEA,OAAO,eAAeG,EAAUR,EAAK,CACjC,IAAK,IAAMS,EAAiB,EAC5B,WAAY,EAChB,CAAC,CACL,CAEA,OAAOD,CACX,CAEA,cAA8B,CAC1B,OAAOpB,EAAU,CACb,MAAO,KAAK,aAAa,EACzB,MAAO,KAAK,MACZ,SAAU,KAAK,SACf,MAAOe,EACP,GAAI,KACJ,MAAO,KAAK,KAChB,CAAC,CACL,CAEA,IAAI,SAAuD,CACvD,MAAO,CACH,MAAO,KAAK,aAAa,EACzB,MAAO,KAAK,MACZ,QAAS,KAAK,QACd,SAAU,KAAK,SACf,QAAS,KAAK,QACd,GAAI,KACJ,MAAO,KAAK,MACZ,MAAOA,CACX,CACJ,CAEA,iBAAiC,CA1QzC,IAAAQ,EA2QY,IAAMC,EAAQ,CAAC,EACf,OAAW,CAACZ,EAAKa,CAAU,IAAK,OAAO,QAAQ7B,CAAe,EAAG,CAC7D,IAAM8B,EAAW,QAAQd,CAAG,GACtBe,EAAY,KAAK,aAAaD,CAAQ,EACtCE,IAAeL,EAAAE,EAAW,UAAX,KAAAF,EAAsB,KAAK,kBAAkBE,EAAW,IAAI,EACjFD,EAAMZ,CAAc,EAAIe,IAAc,KAChC,KAAK,oBAAoBA,EAAWF,EAAW,IAAI,EACnDG,EACV,CACA,OAAOJ,CACX,CAEA,kBAAkBK,EAAmC,CACjD,OAAQA,EAAM,CACV,KAAK,OAAQ,MAAO,GACpB,KAAK,OAAQ,MAAO,GACpB,KAAK,QAAS,MAAO,GACrB,KAAK,OAAQ,MAAO,CAAC,EACrB,KAAK,MAAO,MAAO,CAAC,EACpB,QAAS,OAAO,IACpB,CACJ,CAEA,oBAAoBC,EAAeD,EAAmC,CAClE,OAAQA,EAAM,CACV,KAAK,OACD,OAAO,OAAOC,CAAK,EACvB,KAAK,QACD,OAAOA,IAAU,MAAQA,IAAU,QACvC,KAAK,OACL,KAAK,MACD,GAAI,CACA,OAAO,KAAK,MAAMA,CAAK,CAC3B,MAAQ,CACJ,OAAOD,IAAS,OAAS,CAAC,EAAI,CAAC,CACnC,CACJ,QACI,OAAOC,CACf,CACJ,CAEA,yBAAyBnB,EAAcoB,EAAkBC,EAAkB,CACvE,IAAMC,EAAWtB,EAAK,QAAQ,SAAU,EAAE,EACpCuB,EAAWtC,EAAwBqC,CAAQ,EACjD,GAAI,CAACC,EAAS,OACd,IAAMJ,EAAQ,KAAK,oBAAoBE,EAAUE,EAAQ,IAAI,EAC7D,KAAK,WAAWD,EAAqBH,CAAK,CAC9C,CAEA,WAAWnB,EAAemB,EAAY,CAClC,KAAK,MAAM,MAAQ,CACf,GAAG,KAAK,MAAM,KAAK,EACnB,CAACnB,CAAI,EAAGmB,CACZ,CACJ,CAEA,cAAe,CACX,OAAO,KAAK,MAAM,KACtB,CAEA,eAAgB,CACZ,GAAI,CAAC1B,EAAQ,OAEb,IAAI+B,EAAgB,KAAK,MAAM,KAAK,EAC9BC,EAAU7B,EAAO,IAAM,CACzB,IAAM8B,EAAe,KAAK,MAAM,MAChCjC,EAAO,CACH,GAAG,KAAK,QACR,SAAUiC,EACV,SAAUF,CACd,CAAC,EACDA,EAAgBE,CACpB,CAAC,EAED,KAAK,QAAQ,KAAKD,CAAO,CAC7B,CAEA,aAAc,CACV,GAAI,CAACjC,EAAQ,OAEb,IAAMiC,EAAU/B,EAAQ,KAAM,IAAMF,EAAO,KAAK,OAAO,CAAC,EACxD,KAAK,QAAQ,KAAKiC,CAAO,CAC7B,CAEA,cAAe,CACX,IAAME,EAAgC,CAAE,QAAS,CAAC,CAAE,EACpD,MAAM,KAAK,KAAK,UAAU,EAAE,QAAQC,GAAQ,CAjWxD,IAAAhB,EAkWgB,GAAIgB,aAAgB,QAAS,CACzB,IAAMC,EAAWD,EAAK,aAAa,WAAW,GAAK,UACnDD,EAAME,CAAQ,EAAIF,EAAME,CAAQ,GAAK,CAAC,EACtCF,EAAME,CAAQ,EAAE,KAAKD,CAAI,CAC7B,MAAWhB,EAAAgB,EAAK,cAAL,MAAAhB,EAAkB,QACzBe,EAAM,QAAQ,KAAKC,CAAI,CAE/B,CAAC,EACD,KAAK,MAAQD,CACjB,CAEA,mBAAoB,CAChB,sBAAsB,IAAM,CACxB,KAAK,aAAa,EAClB,KAAK,cAAc,EACnB,KAAK,YAAY,EACjBrC,GAAA,MAAAA,EAAY,KAAK,QACrB,CAAC,CACL,CAEA,sBAAuB,CACnB,KAAK,QAAQ,QAAQmC,GAAWA,EAAQ,CAAC,EACzC,KAAK,QAAU,CAAC,EAChBlC,GAAA,MAAAA,EAAe,KAAK,QACxB,CACJ,CACIP,GACA,eAAe,OAAOA,EAASa,CAAa,CAEpD",
  "names": ["index_exports", "__export", "State", "compute", "createComputed", "createState", "createStore", "defineComponent", "defineStore", "E", "html", "htmlFor", "w", "storeRegistry", "esm_default", "parentNode", "a", "b", "get", "before", "bLength", "aEnd", "bEnd", "aStart", "bStart", "map", "node", "i", "index", "sequence", "isArray", "getPrototypeOf", "getOwnPropertyDescriptor", "SVG_NAMESPACE", "empty", "newRange", "set", "map", "key", "value", "gPD", "ref", "prop", "desc", "getOwnPropertyDescriptor", "getPrototypeOf", "find", "content", "path", "childNodesIndex", "node", "i", "setPrototypeOf", "factory_default", "Class", "Custom", "target", "range", "range_default", "firstChild", "lastChild", "preserve", "newRange", "remove", "firstChild", "lastChild", "preserve", "range_default", "checkType", "diffFragment", "node", "operation", "comment", "value", "_firstChild", "_lastChild", "_nodes", "PersistentFragment", "factory_default", "fragment", "__privateAdd", "empty", "__privateGet", "parentNode", "__privateSet", "setAttribute", "element", "name", "value", "removeAttribute", "aria", "key", "$", "listeners", "at", "known", "set", "current", "isArray", "hole", "detail", "value", "node", "nullish", "className", "element", "maybeDirect", "data", "dataset", "key", "direct", "ref", "name", "dot", "removeAttribute", "regular", "setAttribute", "style", "toggle", "array", "prev", "length", "esm_default", "diffFragment", "range_default", "empty", "attr", "aria", "attribute", "svg", "_a", "at", "gPD", "text", "abc", "a", "b", "c", "bc", "detail", "u", "n", "empty", "cache", "creator_default", "parse", "template", "values", "fragment", "entries", "direct", "root", "details", "empty", "current", "prev", "i", "path", "update", "name", "node", "find", "detail", "array", "hole", "cache", "bc", "PersistentFragment", "TEXT_ELEMENTS", "VOID_ELEMENTS", "elements", "attributes", "holes", "esm_default", "template", "prefix", "xml", "i", "_", "name", "attrs", "selfClosing", "VOID_ELEMENTS", "hole", "template", "svg", "range", "create_content_default", "text", "xml", "SVG_NAMESPACE", "newRange", "content", "createPath", "node", "path", "parentNode", "textNode", "resolve", "template", "values", "xml", "content", "create_content_default", "esm_default", "prefix", "length", "entries", "empty", "replace", "tw", "i", "search", "update", "isArray", "array", "hole", "abc", "name", "attribute", "removeAttribute", "TEXT_ELEMENTS", "text", "childNodes", "len", "set", "cache", "parser_default", "createHTML", "creator_default", "parser_default", "createSVG", "unroll", "info", "s", "t", "v", "b", "c", "value", "detail", "array", "unrollValues", "hole", "current", "Hole", "cache", "stack", "values", "i", "length", "svg", "template", "tag", "svg", "template", "values", "Hole", "html", "known", "shared_default", "where", "what", "check", "info", "set", "cache", "b", "hole", "node", "Hole", "keyed", "createRef", "svg", "ref", "key", "tag", "template", "values", "Hole", "memo", "set", "cache", "htmlFor", "svgFor", "registry", "onGarbageCollected", "held", "debug", "nullHandler", "create", "hold", "handler", "r", "token", "target", "args", "drop", "effects", "onGC", "dispose", "remove", "attach", "effect", "where", "what", "detach", "shared_default", "wr", "create", "drop", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_flags", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "BRAND_SYMBOL", "_refresh", "_unsubscribe", "prev", "next", "subscribe", "fn", "_this", "effect", "prevContext", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "call", "undefined", "_fn", "_globalVersion", "OUTDATED", "err", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "_nextBatchedEffect", "_callback", "finish", "_start", "bind", "_dispose", "State", "u", "value", "currentClone", "cloneDeep", "createState", "initialValue", "baseSignal", "d", "obj", "clonedObj", "key", "compute", "computeFn", "args", "w", "createComputed", "computedFn", "computedSignals", "computedCache", "acc", "fn", "cacheKey", "argCache", "signal", "ComputedManager", "args", "arg", "obj", "item", "acc", "key", "value", "a", "b", "val", "i", "fn", "options", "_a", "_b", "cache", "maxAge", "maxSize", "signal", "w", "cached", "cacheKey", "now", "globalStore", "createStore", "options", "initialState", "gettersFn", "computedFn", "actionsFn", "state", "createState", "getters", "acc", "key", "fn", "computed", "computedProperty", "ComputedManager", "actions", "registerStore", "store", "getStore", "defineStore", "rest", "storeRegistry", "defineComponent", "options", "tagName", "propsDefinition", "initialState", "gettersFn", "computedFn", "actionsFn", "connected", "disconnected", "render", "listen", "uRender", "attach", "E", "CustomElement", "d", "createState", "name", "key", "detail", "getterObj", "storeRegistry", "acc", "fn", "context", "computedObj", "computed", "computedProperty", "ComputedManager", "_a", "props", "definition", "attrName", "attrValue", "defaultValue", "type", "value", "oldValue", "newValue", "propName", "propDef", "previousValue", "cleanup", "currentValue", "slots", "node", "slotName"]
}
