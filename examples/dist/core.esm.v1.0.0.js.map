{
  "version": 3,
  "sources": ["../../node_modules/udomdiff/esm/index.js", "../../node_modules/uhtml/esm/utils.js", "../../node_modules/domconstants/esm/constants.js", "../../node_modules/custom-function/esm/factory.js", "../../node_modules/uhtml/esm/range.js", "../../node_modules/uhtml/esm/persistent-fragment.js", "../../node_modules/uhtml/esm/handler.js", "../../node_modules/uhtml/esm/literals.js", "../../node_modules/uhtml/esm/creator.js", "../../node_modules/domconstants/esm/re.js", "../../node_modules/@webreflection/uparser/esm/index.js", "../../node_modules/uhtml/esm/create-content.js", "../../node_modules/uhtml/esm/parser.js", "../../node_modules/uhtml/esm/rabbit.js", "../../node_modules/uhtml/esm/index.js", "../../node_modules/uhtml/esm/render/shared.js", "../../node_modules/uhtml/esm/keyed.js", "../../node_modules/gc-hook/esm/index.js", "../../node_modules/uhtml/esm/render/reactive.js", "../../node_modules/@preact/signals-core/src/index.ts", "../../src/core/state.ts", "../../src/core/untils.ts", "../../src/core/store.ts", "../../src/core/component.ts"],
  "sourcesContent": ["/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -0).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -0).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "const { isArray } = Array;\nconst { getPrototypeOf, getOwnPropertyDescriptor } = Object;\n\nexport { isArray };\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const empty = [];\n\nexport const newRange = () => document.createRange();\n\n/**\n * Set the `key` `value` pair to the *Map* or *WeakMap* and returns the `value`\n * @template T\n * @param {Map | WeakMap} map\n * @param {any} key\n * @param {T} value\n * @returns {T}\n */\nexport const set = (map, key, value) => {\n  map.set(key, value);\n  return value;\n};\n\n/**\n * Return a descriptor, if any, for the referenced *Element*\n * @param {Element} ref\n * @param {string} prop\n * @returns \n */\nexport const gPD = (ref, prop) => {\n  let desc;\n  do { desc = getOwnPropertyDescriptor(ref, prop); }\n  while(!desc && (ref = getPrototypeOf(ref)));\n  return desc;\n};\n\n/* c8 ignore start */\n/**\n * @param {DocumentFragment} content\n * @param {number[]} path\n * @returns {Element}\n */\nexport const find = (content, path) => path.reduceRight(childNodesIndex, content);\nconst childNodesIndex = (node, i) => node.childNodes[i];\n/* c8 ignore stop */\n", "export const ELEMENT_NODE = 1;\nexport const ATTRIBUTE_NODE = 2;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n", "const {setPrototypeOf} = Object;\n\n/**\n * @param {Function} Class any base class to extend without passing through it via super() call.\n * @returns {Function} an extensible class for the passed one.\n * @example\n *  // creating this very same module utility\n *  import custom from 'custom-function/factory';\n *  const CustomFunction = custom(Function);\n *  class MyFunction extends CustomFunction {}\n *  const mf = new MyFunction(() => {});\n */\nexport default Class => {\n  function Custom(target) {\n    return setPrototypeOf(target, new.target.prototype);\n  }\n  Custom.prototype = Class.prototype;\n  return Custom;\n};\n", "import { newRange } from './utils.js';\n\nlet range;\n/**\n * @param {Node | Element} firstChild\n * @param {Node | Element} lastChild\n * @param {boolean} preserve\n * @returns\n */\nexport default (firstChild, lastChild, preserve) => {\n  if (!range) range = newRange();\n  /* c8 ignore start */\n  if (preserve)\n    range.setStartAfter(firstChild);\n  else\n    range.setStartBefore(firstChild);\n  /* c8 ignore stop */\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n", "import { DOCUMENT_FRAGMENT_NODE } from 'domconstants/constants';\nimport custom from 'custom-function/factory';\nimport drop from './range.js';\nimport { empty } from './utils.js';\n\n/**\n * @param {PersistentFragment} fragment\n * @returns {Node | Element}\n */\nconst remove = ({firstChild, lastChild}, preserve) => drop(firstChild, lastChild, preserve);\n\nlet checkType = false;\n\n/**\n * @param {Node} node\n * @param {1 | 0 | -0 | -1} operation\n * @returns {Node}\n */\nexport const diffFragment = (node, operation) => (\n  checkType && node.nodeType === DOCUMENT_FRAGMENT_NODE ?\n    ((1 / operation) < 0 ?\n      (operation ? remove(node, true) : node.lastChild) :\n      (operation ? node.valueOf() : node.firstChild)) :\n    node\n);\n\nconst comment = value => document.createComment(value);\n\n/** @extends {DocumentFragment} */\nexport class PersistentFragment extends custom(DocumentFragment) {\n  #firstChild = comment('<>');\n  #lastChild = comment('</>');\n  #nodes = empty;\n  constructor(fragment) {\n    super(fragment);\n    this.replaceChildren(...[\n      this.#firstChild,\n      ...fragment.childNodes,\n      this.#lastChild,\n    ]);\n    checkType = true;\n  }\n  get firstChild() { return this.#firstChild; }\n  get lastChild() { return this.#lastChild; }\n  get parentNode() { return this.#firstChild.parentNode; }\n  remove() {\n    remove(this, false);\n  }\n  replaceWith(node) {\n    remove(this, true).replaceWith(node);\n  }\n  valueOf() {\n    const { parentNode } = this;\n    if (parentNode === this) {\n      if (this.#nodes === empty)\n        this.#nodes = [...this.childNodes];\n    }\n    else {\n      /* c8 ignore start */\n      // there are cases where a fragment might be just appended\n      // out of the box without valueOf() invoke (first render).\n      // When these are moved around and lose their parent and,\n      // such parent is not the fragment itself, it's possible there\n      // where changes or mutations in there to take care about.\n      // This is a render-only specific issue but it's tested and\n      // it's worth fixing to me to have more consistent fragments.\n      if (parentNode) {\n        let { firstChild, lastChild } = this;\n        this.#nodes = [firstChild];\n        while (firstChild !== lastChild)\n          this.#nodes.push((firstChild = firstChild.nextSibling));\n      }\n      /* c8 ignore stop */\n      this.replaceChildren(...this.#nodes);\n    }\n    return this;\n  }\n}\n", "import udomdiff from 'udomdiff';\nimport { empty, gPD, isArray, set } from './utils.js';\nimport { diffFragment } from './persistent-fragment.js';\nimport drop from './range.js';\n\nconst setAttribute = (element, name, value) =>\n  element.setAttribute(name, value);\n\n/**\n * @param {Element} element\n * @param {string} name\n * @returns {void}\n */\nexport const removeAttribute = (element, name) =>\n  element.removeAttribute(name);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const aria = (element, value) => {\n  for (const key in value) {\n    const $ = value[key];\n    const name = key === 'role' ? key : `aria-${key}`;\n    if ($ == null) removeAttribute(element, name);\n    else setAttribute(element, name, $);\n  }\n  return value;\n};\n\nlet listeners;\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const at = (element, value, name) => {\n  name = name.slice(1);\n  if (!listeners) listeners = new WeakMap;\n  const known = listeners.get(element) || set(listeners, element, {});\n  let current = known[name];\n  if (current && current[0]) element.removeEventListener(name, ...current);\n  current = isArray(value) ? value : [value, false];\n  known[name] = current;\n  if (current[0]) element.addEventListener(name, ...current);\n  return value;\n};\n\n/** @type {WeakMap<Node, Element | import(\"./persistent-fragment.js\").PersistentFragment>} */\nconst holes = new WeakMap;\n\n/**\n * @template T\n * @param {import(\"./literals.js\").Detail} detail\n * @param {T} value\n * @returns {T}\n */\nexport const hole = (detail, value) => {\n  const { t: node, n: hole } = detail;\n  let nullish = false;\n  switch (typeof value) {\n    case 'object':\n      if (value !== null) {\n        (hole || node).replaceWith((detail.n = value.valueOf()));\n        break;\n      }\n    case 'undefined':\n      nullish = true;\n    default:\n      node.data = nullish ? '' : value;\n      if (hole) {\n        detail.n = null;\n        hole.replaceWith(node);\n      }\n      break;\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const className = (element, value) => maybeDirect(\n  element, value, value == null ? 'class' : 'className'\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const data = (element, value) => {\n  const { dataset } = element;\n  for (const key in value) {\n    if (value[key] == null) delete dataset[key];\n    else dataset[key] = value[key];\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element | CSSStyleDeclaration} ref\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const direct = (ref, value, name) => (ref[name] = value);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const dot = (element, value, name) => direct(element, value, name.slice(1));\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const maybeDirect = (element, value, name) => (\n  value == null ?\n    (removeAttribute(element, name), value) :\n    direct(element, value, name)\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const ref = (element, value) => (\n  (typeof value === 'function' ?\n    value(element) : (value.current = element)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nconst regular = (element, value, name) => (\n  (value == null ?\n    removeAttribute(element, name) :\n    setAttribute(element, name, value)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const style = (element, value) => (\n  value == null ?\n    maybeDirect(element, value, 'style') :\n    direct(element.style, value, 'cssText')\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const toggle = (element, value, name) => (\n  element.toggleAttribute(name.slice(1), value),\n  value\n);\n\n/**\n * @param {Node} node\n * @param {Node[]} value\n * @param {string} _\n * @param {Node[]} prev\n * @returns {Node[]}\n */\nexport const array = (node, value, prev) => {\n  // normal diff\n  const { length } = value;\n  node.data = `[${length}]`;\n  if (length)\n    return udomdiff(node.parentNode, prev, value, diffFragment, node);\n  /* c8 ignore start */\n  switch (prev.length) {\n    case 1:\n      prev[0].remove();\n    case 0:\n      break;\n    default:\n      drop(\n        diffFragment(prev[0], 0),\n        diffFragment(prev.at(-1), -0),\n        false\n      );\n      break;\n  }\n  /* c8 ignore stop */\n  return empty;\n};\n\nexport const attr = new Map([\n  ['aria', aria],\n  ['class', className],\n  ['data', data],\n  ['ref', ref],\n  ['style', style],\n]);\n\n/**\n * @param {HTMLElement | SVGElement} element\n * @param {string} name\n * @param {boolean} svg\n * @returns\n */\nexport const attribute = (element, name, svg) => {\n  switch (name[0]) {\n    case '.': return dot;\n    case '?': return toggle;\n    case '@': return at;\n    default: return (\n      svg || ('ownerSVGElement' in element) ?\n        (name === 'ref' ? ref : regular) :\n        (attr.get(name) || (\n          name in element ?\n            (name.startsWith('on') ?\n              direct :\n              (gPD(element, name)?.set ? maybeDirect : regular)\n            ) :\n            regular\n          )\n        )\n    );\n  }\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const text = (element, value) => (\n  (element.textContent = value == null ? '' : value),\n  value\n);\n", "import { empty } from './utils.js';\n\n/** @typedef {import(\"./persistent-fragment.js\").PersistentFragment} PersistentFragment */\n/** @typedef {import(\"./rabbit.js\").Hole} Hole */\n\n/** @typedef {unknown} Value */\n/** @typedef {Node | Element | PersistentFragment} Target */\n/** @typedef {null | undefined | string | number | boolean | Node | Element | PersistentFragment} DOMValue */\n/** @typedef {Hole | Node} ArrayValue */\n\nexport const abc = (a, b, c) => ({ a, b, c });\n\nexport const bc = (b, c) => ({ b, c });\n\n/**\n * @typedef {Object} Detail\n * @property {any} v the current value of the interpolation / hole\n * @property {function} u the callback to update the value\n * @property {Node} t the target comment node or element\n * @property {string | null | Node} n the attribute name, if any, or `null`\n * @property {Cache | ArrayValue[] | null} c the cache value for this detail\n */\n\n/**\n * @returns {Detail}\n */\nexport const detail = (u, t, n, c) => ({ v: empty, u, t, n, c });\n\n/**\n * @typedef {Object} Entry\n * @property {number[]} a the path to retrieve the node\n * @property {function} b the update function\n * @property {string | null} c the attribute name, if any, or `null`\n */\n\n/**\n * @typedef {Object} Cache\n * @property {null | TemplateStringsArray} a the cached template\n * @property {null | Node | PersistentFragment} b the node returned when parsing the template\n * @property {Detail[]} c the list of updates to perform\n */\n\n/**\n * @returns {Cache}\n */\nexport const cache = () => abc(null, null, empty);\n", "import { PersistentFragment } from './persistent-fragment.js';\nimport { bc, detail } from './literals.js';\nimport { array, hole } from './handler.js';\nimport { empty, find } from './utils.js';\nimport { cache } from './literals.js';\n\n/** @param {(template: TemplateStringsArray, values: any[]) => import(\"./parser.js\").Resolved} parse */\nexport default parse => (\n  /**\n   * @param {TemplateStringsArray} template\n   * @param {any[]} values\n   * @returns {import(\"./literals.js\").Cache}\n   */\n  (template, values) => {\n    const { a: fragment, b: entries, c: direct } = parse(template, values);\n    const root = document.importNode(fragment, true);\n    /** @type {import(\"./literals.js\").Detail[]} */\n    let details = empty;\n    if (entries !== empty) {\n      details = [];\n      for (let current, prev, i = 0; i < entries.length; i++) {\n        const { a: path, b: update, c: name } = entries[i];\n        const node = path === prev ? current : (current = find(root, (prev = path)));\n        details[i] = detail(\n          update,\n          node,\n          name,\n          update === array ? [] : (update === hole ? cache() : null)\n        );\n      }\n    }\n    return bc(\n      direct ? root.firstChild : new PersistentFragment(root),\n      details,\n    );\n  }\n);\n", "export const TEXT_ELEMENTS = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\nexport const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n", "import { VOID_ELEMENTS } from 'domconstants/re';\n\nconst elements = /<([a-zA-Z0-9]+[a-zA-Z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} xml enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, xml) => {\n  let i = 0;\n  return template\n    .join('\\x01')\n    .trim()\n    .replace(\n      elements,\n      (_, name, attrs, selfClosing) => `<${ name }${ attrs.replace(attributes, '\\x02=$2$1').trimEnd() }${ selfClosing ? ( (xml || VOID_ELEMENTS.test(name)) ? ' /' :`></${name}`) : '' }>`\n    )\n    .replace(\n      holes,\n      hole => hole === '\\x01' ? `<!--${prefix + i++}-->` : (prefix + i++)\n    )\n  ;\n};\n", "import { SVG_NAMESPACE, newRange } from './utils.js';\n\nlet template = document.createElement('template'), svg, range;\n\n/**\n * @param {string} text\n * @param {boolean} xml\n * @returns {DocumentFragment}\n */\nexport default (text, xml) => {\n  if (xml) {\n    if (!svg) {\n      svg = document.createElementNS(SVG_NAMESPACE, 'svg');\n      range = newRange();\n      range.selectNodeContents(svg);\n    }\n    return range.createContextualFragment(text);\n  }\n  template.innerHTML = text;\n  const { content } = template;\n  template = template.cloneNode(false);\n  return content;\n};\n", "import { COMMENT_NODE, ELEMENT_NODE } from 'domconstants/constants';\nimport { TEXT_ELEMENTS } from 'domconstants/re';\nimport parser from '@webreflection/uparser';\n\nimport { empty, isArray, set } from './utils.js';\nimport { abc } from './literals.js';\n\nimport { array, attribute, hole, text, removeAttribute } from './handler.js';\nimport createContent from './create-content.js';\n\n/** @typedef {import(\"./literals.js\").Entry} Entry */\n\n/**\n * @typedef {Object} Resolved\n * @param {DocumentFragment} f content retrieved from the template\n * @param {Entry[]} e entries per each hole in the template\n * @param {boolean} d direct node to handle\n */\n\n/**\n * @param {Element} node\n * @returns {number[]}\n */\nconst createPath = node => {\n  const path = [];\n  let parentNode;\n  while ((parentNode = node.parentNode)) {\n    path.push(path.indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n  }\n  return path;\n};\n\nconst textNode = () => document.createTextNode('');\n\n/**\n * @param {TemplateStringsArray} template\n * @param {boolean} xml\n * @returns {Resolved}\n */\nconst resolve = (template, values, xml) => {\n  const content = createContent(parser(template, prefix, xml), xml);\n  const { length } = template;\n  let entries = empty;\n  if (length > 1) {\n    const replace = [];\n    const tw = document.createTreeWalker(content, 1 | 128);\n    let i = 0, search = `${prefix}${i++}`;\n    entries = [];\n    while (i < length) {\n      const node = tw.nextNode();\n      // these are holes or arrays\n      if (node.nodeType === COMMENT_NODE) {\n        if (node.data === search) {\n          // \u26A0\uFE0F once array, always array!\n          const update = isArray(values[i - 1]) ? array : hole;\n          if (update === hole) replace.push(node);\n          entries.push(abc(createPath(node), update, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n      else {\n        let path;\n        // these are attributes\n        while (node.hasAttribute(search)) {\n          if (!path) path = createPath(node);\n          const name = node.getAttribute(search);\n          entries.push(abc(path, attribute(node, name, xml), name));\n          removeAttribute(node, search);\n          search = `${prefix}${i++}`;\n        }\n        // these are special text-only nodes\n        if (\n          !xml &&\n          TEXT_ELEMENTS.test(node.localName) &&\n          node.textContent.trim() === `<!--${search}-->`\n        ) {\n          entries.push(abc(path || createPath(node), text, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n    }\n    // can't replace holes on the fly or the tree walker fails\n    for (i = 0; i < replace.length; i++)\n      replace[i].replaceWith(textNode());\n  }\n\n  // need to decide if there should be a persistent fragment\n  const { childNodes } = content;\n  let { length: len } = childNodes;\n\n  // html`` or svg`` to signal an empty content\n  // these nodes can be passed directly as never mutated\n  if (len < 1) {\n    len = 1;\n    content.appendChild(textNode());\n  }\n  // html`${'b'}` or svg`${[]}` cases\n  else if (\n    len === 1 &&\n    // ignore html`static` or svg`static` because\n    // these nodes can be passed directly as never mutated\n    length !== 1 &&\n    childNodes[0].nodeType !== ELEMENT_NODE\n  ) {\n    // use a persistent fragment for these cases too\n    len = 0;\n  }\n\n  return set(cache, template, abc(content, entries, len === 1));\n};\n\n/** @type {WeakMap<TemplateStringsArray, Resolved>} */\nconst cache = new WeakMap;\nconst prefix = 'is\u00B5';\n\n/**\n * @param {boolean} xml\n * @returns {(template: TemplateStringsArray, values: any[]) => Resolved}\n */\nexport default xml => (template, values) => cache.get(template) || resolve(template, values, xml);\n", "import { array, hole } from './handler.js';\nimport { cache } from './literals.js';\nimport create from './creator.js';\nimport parser from './parser.js';\n\nconst createHTML = create(parser(false));\nconst createSVG = create(parser(true));\n\n/**\n * @param {import(\"./literals.js\").Cache} info\n * @param {Hole} hole\n * @returns {Node}\n */\nconst unroll = (info, { s, t, v }) => {\n  if (info.a !== t) {\n    const { b, c } = (s ? createSVG : createHTML)(t, v);\n    info.a = t;\n    info.b = b;\n    info.c = c;\n  }\n  for (let { c } = info, i = 0; i < c.length; i++) {\n    const value = v[i];\n    const detail = c[i];\n    switch (detail.u) {\n      case array:\n        detail.v = array(\n          detail.t,\n          unrollValues(detail.c, value),\n          detail.v\n        );\n        break;\n      case hole:\n        const current = value instanceof Hole ?\n          unroll(detail.c || (detail.c = cache()), value) :\n          (detail.c = null, value)\n        ;\n        if (current !== detail.v)\n          detail.v = hole(detail, current);\n        break;\n      default:\n        if (value !== detail.v)\n          detail.v = detail.u(detail.t, value, detail.n, detail.v);\n        break;\n    }\n  }\n  return info.b;\n};\n\n/**\n * @param {Cache} cache\n * @param {any[]} values\n * @returns {number}\n */\nconst unrollValues = (stack, values) => {\n  let i = 0, { length } = values;\n  if (length < stack.length) stack.splice(length);\n  for (; i < length; i++) {\n    const value = values[i];\n    if (value instanceof Hole)\n      values[i] = unroll(stack[i] || (stack[i] = cache()), value);\n    else stack[i] = null;\n  }\n  return values;\n};\n\n/**\n * Holds all details needed to render the content on a render.\n * @constructor\n * @param {boolean} svg The content type.\n * @param {TemplateStringsArray} template The template literals used to the define the content.\n * @param {any[]} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(svg, template, values) {\n    this.s = svg;\n    this.t = template;\n    this.v = values;\n  }\n  toDOM(info = cache()) {\n    return unroll(info, this);\n  }\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\n\nimport render from './render/hole.js';\n\n/** @typedef {import(\"./literals.js\").Value} Value */\n\nconst tag = svg => (template, ...values) => new Hole(svg, template, values);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render HTML content. */\nexport const html = tag(false);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render SVG content. */\nexport const svg = tag(true);\n\nexport { Hole, render, attr };\n", "import { Hole } from '../rabbit.js';\nimport { cache } from '../literals.js';\nimport { set } from '../utils.js';\n\n/** @type {WeakMap<Element | DocumentFragment, import(\"../literals.js\").Cache>} */\nconst known = new WeakMap;\n\n/**\n  * Render with smart updates within a generic container.\n  * @template T\n  * @param {T} where the DOM node where to render content\n  * @param {(() => Hole) | Hole} what the hole to render\n  * @param {boolean} check does a `typeof` check (internal usage).\n  * @returns\n  */\nexport default (where, what, check) => {\n  const info = known.get(where) || set(known, where, cache());\n  const { b } = info;\n  const hole = (check && typeof what === 'function') ? what() : what;\n  const node = hole instanceof Hole ? hole.toDOM(info) : hole;\n  if (b !== node)\n    where.replaceChildren((info.b = node).valueOf());\n  return where;\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\nimport { cache } from './literals.js';\nimport { set } from './utils.js';\nimport { html, svg } from './index.js';\n\nimport render from './render/keyed.js';\n\n/** @typedef {import(\"./literals.js\").Cache} Cache */\n/** @typedef {import(\"./literals.js\").Target} Target */\n/** @typedef {import(\"./literals.js\").Value} Value */\n\n/** @typedef {(ref:Object, key:string | number) => Tag} Bound */\n\n/**\n * @callback Tag\n * @param {TemplateStringsArray} template\n * @param  {...Value} values\n * @returns {Target}\n */\n\nconst keyed = new WeakMap;\nconst createRef = svg => /** @type {Bound} */ (ref, key) => {\n  /** @type {Tag} */\n  function tag(template, ...values) {\n    return new Hole(svg, template, values).toDOM(this);\n  }\n\n  const memo = keyed.get(ref) || set(keyed, ref, new Map);\n  return memo.get(key) || set(memo, key, tag.bind(cache()));\n};\n\n/** @type {Bound} Returns a bound tag to render HTML content. */\nexport const htmlFor = createRef(false);\n\n/** @type {Bound} Returns a bound tag to render SVG content. */\nexport const svgFor = createRef(true);\n\nexport { Hole, render, html, svg, attr };\n", "// (c) Andrea Giammarchi - ISC\n\nconst registry = new FinalizationRegistry(\n  ([onGarbageCollected, held, debug]) => {\n    // \"%cThis is a green text\", \"color:green\"\n    if (debug) console.debug(`%c${String(held)}`, 'font-weight:bold', 'collected');\n    onGarbageCollected(held);\n  }\n);\n\nconst nullHandler = Object.create(null);\n\n/**\n * @template {unknown} H\n * @typedef {Object} GCHookOptions\n * @prop {boolean} [debug=false] if `true`, logs values once these can get collected.\n * @prop {ProxyHandler<object>} [handler] optional proxy handler to use instead of the default one.\n * @prop {H} [return=H] if specified, overrides the returned proxy with its value.\n * @prop {unknown} [token=H] it's the held value by default, but it can be any other token except the returned value itself.\n */\n\n/**\n * @template {unknown} H\n * @param {H} hold the reference to hold behind the scene and passed along the callback once it triggers.\n * @param {(held:H) => void} onGarbageCollected the callback that will receive the held value once its wrapper or indirect reference is no longer needed.\n * @param {GCHookOptions<H>} [options] an optional configuration object to change some default behavior.\n */\nexport const create = (\n  hold,\n  onGarbageCollected,\n  { debug, handler, return: r, token = hold } = nullHandler\n) => {\n  // if no reference to return is defined,\n  // create a proxy for the held one and register that instead.\n  /** @type {H} */\n  const target = r || new Proxy(hold, handler || nullHandler);\n  const args = [target, [onGarbageCollected, hold, !!debug]];\n  if (token !== false) args.push(token);\n  // register the target reference in a way that\n  // the `onGarbageCollected(held)` callback will eventually notify.\n  registry.register(...args);\n  return target;\n};\n\n/**\n * If previously registered as either `token` or `hold` value, allow explicit removal of the entry in the registry.\n * @param {unknown} token the token used during registration. If no `token` was passed, this can be the same `hold` reference.\n * @returns {boolean} `true` if successfully unregistered.\n */\nexport const drop = token => registry.unregister(token);\n", "import { create, drop } from 'gc-hook';\n\nimport render from './shared.js';\n\n/** @typedef {import(\"../rabbit.js\").Hole} Hole */\n\n/** @type {WeakMap<Element | DocumentFragment, Function>} */\nconst effects = new WeakMap;\n\n/**\n * @param {Function} dispose\n * @returns {void}\n */\nconst onGC = dispose => dispose();\n\nlet remove = true;\n\n/**\n * @param {Function} effect the reactive `effect` callback provided by a 3rd party library.\n * @returns \n */\nexport const attach = effect => {\n  /**\n   * Render with smart updates within a generic container.\n   * If the `what` is a function, it automatically create\n   * an effect for the render function.\n   * @template T\n   * @param {T} where the DOM node where to render content\n   * @param {(() => Hole) | Hole} what the hole to render\n   * @returns {T}\n   */\n  return (where, what) => {\n    remove = typeof what !== 'function';\n    detach(where);\n\n    if (remove) return render(where, what, false);\n    remove = true;\n\n    const wr = new WeakRef(where);\n    const dispose = effect(() => { render(wr.deref(), what(), false) });\n    effects.set(where, dispose);\n    return create(dispose, onGC, { return: where });\n  };\n};\n\n/**\n * Allow manual cleanup of subscribed signals.\n * @param {Element} where a reference container previously used to render signals.\n */\nexport const detach = where => {\n  const dispose = effects.get(where);\n  if (dispose) {\n    if (remove) effects.delete(where);\n    drop(dispose);\n    dispose();\n  }\n};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(() => {\n\t\tconst value = this.value;\n\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n\treturn new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(fn: EffectFn);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n\tconst effect = new Effect(fn);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { computed, effect, batch, untracked, Signal, ReadonlySignal };\n", "import { ReadonlySignal, Signal, signal as createSignal, computed as preactComputed } from '@preact/signals-core';\r\nimport { ComputedProperties } from './component';\r\n\r\n\r\nexport class State<T> extends Signal<T> {\r\n    emit(value: Partial<T> | T): void {\r\n        if (typeof value === 'object' && value !== null && typeof this.value === 'object') {\r\n            const currentClone = cloneDeep(this.value);\r\n            this.value = { ...currentClone, ...value } as T;\r\n        } else {\r\n            this.value = value as T;\r\n        }\r\n    }\r\n}\r\n\r\nexport function createState<T>(initialValue: T): State<T> {\r\n    const baseSignal = createSignal(initialValue);\r\n    Object.setPrototypeOf(baseSignal, State.prototype);\r\n    return baseSignal as State<T>;\r\n}\r\n\r\n\r\nfunction cloneDeep<T>(obj: T): T {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n        return obj.map(cloneDeep) as unknown as T;\r\n    }\r\n\r\n    const clonedObj: Record<PropertyKey, any> = {};\r\n    for (const key of Reflect.ownKeys(obj)) {\r\n        clonedObj[key as keyof typeof obj] = cloneDeep((obj as Record<PropertyKey, any>)[key]);\r\n    }\r\n\r\n    return clonedObj as T;\r\n}\r\n\r\nexport type ComputedResult<T, Args extends any[]> = (...args: Args) => T;\r\n\r\nexport function compute<R, Args extends any[]>(\r\n    computeFn: (...args: Args) => R\r\n): ComputedResult<R, Args> {\r\n    return (...args: Args) => {\r\n        const signal = preactComputed(() => computeFn(...args));\r\n        return signal.value;\r\n    };\r\n}\r\n\r\n\r\nexport function createComputed<C extends Record<string, (...args: any[]) => any>>(\r\n    computedFn: () => C\r\n): ComputedProperties<C> {\r\n    const computedSignals = new Map<string, any>();\r\n    const computedCache = new Map<string, Map<string, any>>(); // \u041A\u044D\u0448 \u0434\u043B\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0439 \u0441 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430\u043C\u0438\r\n\r\n    const computed = Object.entries(computedFn()).reduce((acc, [key, fn]) => {\r\n        if (fn.length === 0) {\r\n            // \u041A\u044D\u0448\u0438\u0440\u0443\u0435\u043C \u0432\u044B\u0447\u0438\u0441\u043B\u0435\u043D\u0438\u044F \u0431\u0435\u0437 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432\r\n            if (!computedSignals.has(key)) {\r\n                computedSignals.set(key, preactComputed(() => fn()));\r\n            }\r\n            return {\r\n                ...acc,\r\n                [key]: () => computedSignals.get(key).value,\r\n            };\r\n        }\r\n\r\n        // \u0414\u043B\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0439 \u0441 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430\u043C\u0438 \u0441\u043E\u0437\u0434\u0430\u0451\u043C \u043A\u044D\u0448\r\n        return {\r\n            ...acc,\r\n            [key]: (...args: any[]) => {\r\n                const cacheKey = JSON.stringify(args); // \u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F \u043A\u043B\u044E\u0447\u0430 \u0434\u043B\u044F \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432\r\n                let argCache = computedCache.get(key);\r\n\r\n                if (!argCache) {\r\n                    argCache = new Map<string, any>();\r\n                    computedCache.set(key, argCache);\r\n                }\r\n\r\n                if (!argCache.has(cacheKey)) {\r\n                    const signal = preactComputed(() => fn(...args));\r\n                    argCache.set(cacheKey, signal);\r\n                }\r\n\r\n                return argCache.get(cacheKey).value;\r\n            },\r\n        };\r\n    }, {} as ComputedProperties<C>);\r\n\r\n    return computed;\r\n}\r\n", "import { ReadonlySignal, Signal, computed as preactComputed } from '@preact/signals-core';\r\n\r\ninterface ComputedCache<T> {\r\n    signal: Signal<T>;\r\n    args: unknown[];\r\n    lastAccessed: number;\r\n}\r\n\r\nexport class ComputedManager {\r\n    private static maxCacheSize = 1000;\r\n    private static cleanupThreshold = 0.8;\r\n    private static cacheTimeout = 5 * 60 * 1000;\r\n\r\n    private static createCacheKey(args: unknown[]): string {\r\n        return args.map(arg => {\r\n            if (arg === null) return 'null';\r\n            if (arg === undefined) return 'undefined';\r\n            if (typeof arg === 'object') {\r\n                const obj = arg as Record<string, unknown>;\r\n                if ('id' in obj) return String(obj.id);\r\n                if ('key' in obj) return String(obj.key);\r\n\r\n                return JSON.stringify(this.sortObjectKeys(obj));\r\n            }\r\n            return String(arg);\r\n        }).join('|');\r\n    }\r\n\r\n    private static sortObjectKeys<T extends object>(obj: T): T {\r\n        if (Array.isArray(obj)) {\r\n            return obj.map(item =>\r\n                typeof item === 'object' && item !== null ? this.sortObjectKeys(item) : item\r\n            ) as unknown as T;\r\n        }\r\n        return Object.keys(obj)\r\n            .sort()\r\n            .reduce((acc, key) => {\r\n                const value = obj[key as keyof T];\r\n                (acc as any)[key] = typeof value === 'object' && value !== null\r\n                    ? this.sortObjectKeys(value)\r\n                    : value;\r\n                return acc;\r\n            }, {} as T);\r\n    }\r\n\r\n    private static argsEqual(a: unknown[], b: unknown[]): boolean {\r\n        if (a.length !== b.length) return false;\r\n        return a.every((val, i) => {\r\n            if (Object.is(val, b[i])) return true;\r\n            if (typeof val === 'object' && val && typeof b[i] === 'object' && b[i]) {\r\n                return JSON.stringify(this.sortObjectKeys(val as object)) ===\r\n                    JSON.stringify(this.sortObjectKeys(b[i] as object));\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    public static createComputed<T, Args extends unknown[]>(\r\n        fn: (...args: Args) => T,\r\n        options: {\r\n            maxAge?: number;\r\n            cacheSize?: number;\r\n        } = {}\r\n    ): (...args: Args) => T {\r\n        const cache = new Map<string, ComputedCache<T>>();\r\n        const maxAge = options.maxAge ?? this.cacheTimeout;\r\n        const maxSize = options.cacheSize ?? this.maxCacheSize;\r\n\r\n        return (...args: Args): T => {\r\n\r\n            if (args.length === 0) {\r\n                if (!cache.has('_')) {\r\n                    const signal = preactComputed(() => fn(...args));\r\n                    cache.set('_', {\r\n                        signal,\r\n                        args: [],\r\n                        lastAccessed: Date.now()\r\n                    });\r\n                }\r\n                const cached = cache.get('_')!;\r\n                cached.lastAccessed = Date.now();\r\n                return cached.signal.value;\r\n            }\r\n\r\n            const cacheKey = this.createCacheKey(args);\r\n            const cached = cache.get(cacheKey);\r\n\r\n            if (cached && this.argsEqual(cached.args, args)) {\r\n                const now = Date.now();\r\n                if (now - cached.lastAccessed <= maxAge) {\r\n                    cached.lastAccessed = now;\r\n                    return cached.signal.value;\r\n                }\r\n            }\r\n\r\n            if (cache.size >= maxSize * this.cleanupThreshold) {\r\n                this.cleanup(cache, maxAge);\r\n            }\r\n\r\n            const signal = preactComputed(() => fn(...args));\r\n            cache.set(cacheKey, {\r\n                signal,\r\n                args: [...args],\r\n                lastAccessed: Date.now()\r\n            });\r\n\r\n            return signal.value;\r\n        };\r\n    }\r\n\r\n    private static cleanup<T>(\r\n        cache: Map<string, ComputedCache<T>>,\r\n        maxAge: number\r\n    ): void {\r\n        const now = Date.now();\r\n        for (const [key, value] of cache.entries()) {\r\n            if (now - value.lastAccessed > maxAge) {\r\n                cache.delete(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function createComputedProperty<T, Args extends unknown[]>(\r\n    fn: (...args: Args) => T,\r\n    options?: { maxAge?: number; cacheSize?: number }\r\n): (...args: Args) => T {\r\n    return ComputedManager.createComputed(fn, options);\r\n}\r\n\r\nexport type ComputedProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReadonlySignal<ReturnType<C[K]>>\r\n    : never;\r\n};\r\n\r\nexport type InferComputedType<T> = T extends (...args: any[]) => any\r\n    ? ReturnType<T>\r\n    : never;", "import { State, createState } from './state';\r\nimport { ComputedProperties, GettersProperties } from './component';\r\nimport { ComputedManager } from './untils';\r\n\r\ntype ComputedFn<S> = (context: {\r\n    state: State<S>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\ntype ActionsFn<S, C> = (context: {\r\n    state: State<S>;\r\n    computed: ComputedProperties<C>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\ntype GettersFn<S> = ComputedFn<S>;\r\n\r\nexport interface StoreOptions<S = any, G extends GettersFn<S> = any, C extends ComputedFn<S> = any, A extends ActionsFn<S, ReturnType<C>> = any> {\r\n    state: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n}\r\n\r\nexport interface StoreContext<S, G extends GettersFn<S>, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>> {\r\n    state: State<S>;\r\n    getters: GettersProperties<ReturnType<G>>;\r\n    computed: ComputedProperties<ReturnType<C>>;\r\n    actions: ReturnType<A>;\r\n}\r\n\r\nexport interface GlobalStore extends Record<string, StoreContext<any, any, any, any>> { }\r\n\r\nexport interface StoreRegistry {\r\n    list: Partial<GlobalStore>;\r\n    $: <K extends keyof GlobalStore, >(key: K) => GlobalStore[K];\r\n    register: <K extends keyof GlobalStore>(\r\n        key: K,\r\n        store: GlobalStore[K]\r\n    ) => void;\r\n}\r\n\r\nconst globalStore: Partial<GlobalStore> = {};\r\n\r\nexport function createStore<S, G extends GettersFn<S>, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>>(\r\n    options: StoreOptions<S, G, C, A>\r\n): StoreContext<S, G, C, A> {\r\n    const { state: initialState, getters: gettersFn, computed: computedFn, actions: actionsFn } = options;\r\n\r\n    const state = createState(initialState);\r\n\r\n    const getters = gettersFn\r\n        ? Object.entries(gettersFn({ state })).reduce((acc, [key, fn]) => ({\r\n            ...acc,\r\n            [key]: fn()\r\n        }), {}) as GettersProperties<ReturnType<G>>\r\n        : ({} as GettersProperties<ReturnType<G>>);\r\n\r\n    // \u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 computed\r\n    const computed = computedFn\r\n        ? Object.entries(computedFn({ state })).reduce((acc, [key, fn]) => {\r\n            const computedProperty = ComputedManager.createComputed(\r\n                () => fn(),\r\n                {\r\n                    maxAge: 15 * 60 * 1000, // 15 \u043C\u0438\u043D\u0443\u0442 \u0434\u043B\u044F store computed\r\n                    cacheSize: 500 // \u0431\u043E\u043B\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F store\r\n                }\r\n            );\r\n\r\n            return {\r\n                ...acc,\r\n                [key]: {\r\n                    get value() {\r\n                        return computedProperty();\r\n                    }\r\n                }\r\n            };\r\n        }, {}) as ComputedProperties<ReturnType<C>>\r\n        : ({} as ComputedProperties<ReturnType<C>>);\r\n\r\n    const actions = actionsFn\r\n        ? (actionsFn({\r\n            state,\r\n            computed\r\n        }) as ReturnType<A>)\r\n        : ({} as ReturnType<A>);\r\n\r\n    return { state, getters, computed, actions };\r\n}\r\n\r\nfunction registerStore<K extends keyof GlobalStore>(\r\n    key: K,\r\n    store: GlobalStore[K]\r\n): void {\r\n    if (globalStore[key]) {\r\n        throw new Error(`Store \"${key}\" already exists`);\r\n    }\r\n    globalStore[key] = store;\r\n\r\n}\r\n\r\nfunction getStore<K extends keyof GlobalStore>(key: K): GlobalStore[K] {\r\n    const store = globalStore[key];\r\n    if (!store) {\r\n        throw new Error(`Store \"${key}\" not found`);\r\n    }\r\n    return store;\r\n}\r\n\r\nexport function defineStore<\r\n    S extends object,\r\n    G extends GettersFn<S>,\r\n    C extends Record<string, (...args: any[]) => any>,\r\n    A extends ActionsFn<S, C>\r\n>(options: {\r\n    key: keyof GlobalStore;\r\n    state: S;\r\n    getters?: G;\r\n    computed?: (context: { state: State<S> }) => C;\r\n    actions?: A;\r\n}) {\r\n    const { key, state, ...rest } = options;\r\n    const store = createStore({ state: state, ...rest });\r\n    storeRegistry.register(key, store);\r\n    return store;\r\n}\r\n\r\nexport const storeRegistry: StoreRegistry = {\r\n    list: globalStore,\r\n    $: getStore,\r\n    register: registerStore,\r\n};", "import { reactive } from 'uhtml/reactive';\r\nimport { effect, ReadonlySignal, Signal, signal, computed as preactComputed } from '@preact/signals-core';\r\nimport { State, createState } from './state';\r\nimport { StoreRegistry, storeRegistry } from './store';\r\nimport { ComputedManager } from './untils';\r\n\r\ntype ConstructorToType<T> =\r\n    T extends StringConstructor ? string :\r\n    T extends NumberConstructor ? number :\r\n    T extends BooleanConstructor ? boolean :\r\n    T extends ArrayConstructor ? T[] :\r\n    T extends ObjectConstructor ? Record<string, unknown> :\r\n    T;\r\n\r\ntype ModelPropDefinition<T> = {\r\n    type: TypeConstructor;\r\n    default?: T;\r\n    model?: { __type: T };\r\n};\r\n\r\ntype SimplePropDefinition<T extends TypeConstructor> = {\r\n    type: T;\r\n    default?: ConstructorToType<T>;\r\n};\r\n\r\ntype PropDefinition<T = unknown> =\r\n    T extends TypeConstructor\r\n    ? SimplePropDefinition<T>\r\n    : ModelPropDefinition<T>;\r\n\r\ntype InferPropType<T> =\r\n    T extends SimplePropDefinition<infer U>\r\n    ? ConstructorToType<U>\r\n    : T extends ModelPropDefinition<infer M>\r\n    ? M\r\n    : never;\r\n\r\ntype InferProps<T extends Record<string, PropDefinition>> = {\r\n    [K in keyof T]: InferPropType<T[K]>;\r\n};\r\n\r\nexport type ComputedProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReturnType<C[K]>\r\n    : never;\r\n};\r\n\r\nexport type GettersProperties<C> = {\r\n    [K in keyof C]: C[K] extends (...args: any[]) => any\r\n    ? ReturnType<C[K]>\r\n    : never;\r\n};\r\n\r\ntype TypeConstructor =\r\n    | StringConstructor\r\n    | NumberConstructor\r\n    | BooleanConstructor\r\n    | ObjectConstructor\r\n    | ArrayConstructor;\r\n\r\ntype BaseContext<P, S> = {\r\n    props: P;\r\n    el: CustomHtmlElement;\r\n    slots: Record<string, Node[]>,\r\n    state: State<S>;\r\n    store: StoreRegistry;\r\n};\r\n\r\ntype GettersFn<P, S> = (context: BaseContext<P, S>) => Record<string, () => any>;\r\ntype ComputedFn<P, S> = (context: BaseContext<P, S>) => Record<string, () => any>;\r\ntype ActionsFn<P, S, C> = (context: BaseContext<P, S> & {\r\n    computed: ComputedProperties<C>;\r\n}) => Record<string, (...args: any[]) => any>;\r\n\r\nexport interface ComponentContext<\r\n    P,\r\n    S,\r\n    G extends GettersFn<P, S>,\r\n    C extends ComputedFn<P, S>,\r\n    A extends ActionsFn<P, S, ReturnType<C>>\r\n> {\r\n    props: P;\r\n    state: State<S>;\r\n    getters: GettersProperties<ReturnType<G>>;\r\n    computed: ComputedProperties<ReturnType<C>>;\r\n    actions: ReturnType<A>;\r\n    el: CustomHtmlElement;\r\n    slots: Record<string, Node[]>;\r\n    store: StoreRegistry;\r\n}\r\n\r\nexport interface CustomHtmlElement extends HTMLElement {\r\n    $<T = any>(key: string): T | undefined;\r\n    emitEvent<T = any>(name: string, detail?: T): void;\r\n}\r\n\r\nexport interface ComponentOptions2<\r\n    P extends Record<string, PropDefinition> = any,\r\n    S = any,\r\n    G extends GettersFn<InferProps<P>, S> = any,\r\n    C extends ComputedFn<InferProps<P>, S> = any,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>> = any\r\n> {\r\n    tagName: string;\r\n    props?: P;\r\n    state?: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n    connected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n    render?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => unknown;\r\n    listen?: (params: ComponentContext<InferProps<P>, S, G, C, A> & {\r\n        newValue: S;\r\n        oldValue: S;\r\n    }) => void;\r\n    disconnected?: (context: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n}\r\n\r\n\r\n\r\ntype ComponentOptions<\r\n    P extends Record<string, PropDefinition>,\r\n    S,\r\n    G extends GettersFn<InferProps<P>, S>,\r\n    C extends ComputedFn<InferProps<P>, S>,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>>\r\n> = {\r\n    tagName: string;\r\n    props?: P;\r\n    state?: S;\r\n    getters?: G;\r\n    computed?: C;\r\n    actions?: A;\r\n    connected?: (ctx: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n    render?: (ctx: ComponentContext<InferProps<P>, S, G, C, A>) => unknown;\r\n    listen?: (ctx: ComponentContext<InferProps<P>, S, G, C, A> & {\r\n        newValue: S;\r\n        oldValue: S;\r\n    }) => void;\r\n    disconnected?: (ctx: ComponentContext<InferProps<P>, S, G, C, A>) => void;\r\n};\r\n\r\n\r\nexport function defineComponent<\r\n    P extends Record<string, PropDefinition>,\r\n    S,\r\n    G extends GettersFn<InferProps<P>, S>,\r\n    C extends ComputedFn<InferProps<P>, S>,\r\n    A extends ActionsFn<InferProps<P>, S, ReturnType<C>>\r\n>(options: ComponentOptions<P, S, G, C, A>) {\r\n    const {\r\n        tagName,\r\n        props: propsDefinition = {} as P,\r\n        state: initialState,\r\n        getters: gettersFn = (() => ({})) as GettersFn<InferProps<P>, S>,\r\n        computed: computedFn = (() => ({})) as ComputedFn<InferProps<P>, S>,\r\n        actions: actionsFn = (() => ({})) as ActionsFn<InferProps<P>, S, ReturnType<ComputedFn<InferProps<P>, S>>>,\r\n        connected,\r\n        disconnected,\r\n        render,\r\n        listen\r\n    } = options;\r\n\r\n    const uRender = reactive(effect);\r\n\r\n    class CustomElement extends HTMLElement implements CustomHtmlElement {\r\n        props: Signal<InferProps<P>>;\r\n        state: State<S>;\r\n        getters: GettersProperties<ReturnType<G>>;\r\n        computed: ComputedProperties<ReturnType<C>>;\r\n        actions: ReturnType<A>;\r\n        slots: Record<string, Node[]> = {};\r\n        cleanup: (() => void)[] = [];\r\n\r\n        static get observedAttributes() {\r\n            return Object.keys(propsDefinition).map((name) => `data-${name}`);\r\n        }\r\n\r\n        constructor() {\r\n            super();\r\n            this.props = signal({} as InferProps<P>);\r\n            this.props.value = this.initializeProps();\r\n            this.state = createState(initialState as S);\r\n            this.getters = this.setupGetters();\r\n            this.computed = this.setupComputed();\r\n            this.actions = this.setupActions();\r\n        }\r\n\r\n        public $<T = any>(key: string) {\r\n            return (this as any)[key] as T | undefined;\r\n        }\r\n\r\n        public emitEvent<T = any>(name: string, detail: T = {} as T): void {\r\n            this.dispatchEvent(new CustomEvent(name, { detail }));\r\n        }\r\n\r\n        setupGetters(): GettersProperties<ReturnType<G>> {\r\n            const getterObj = gettersFn({\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            });\r\n\r\n            return Object.entries(getterObj).reduce((acc, [key, fn]) => ({\r\n                ...acc,\r\n                [key]: fn()\r\n            }), {}) as GettersProperties<ReturnType<G>>;\r\n        }\r\n\r\n        setupComputed(): ComputedProperties<ReturnType<C>> {\r\n            const context = {\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            };\r\n\r\n            const computedObj = computedFn(context);\r\n            const computed = {} as ComputedProperties<ReturnType<C>>;\r\n\r\n            // \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C ComputedManager \u0434\u043B\u044F \u043A\u0430\u0436\u0434\u043E\u0433\u043E computed \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\r\n            for (const [key, fn] of Object.entries(computedObj)) {\r\n                const computedProperty = ComputedManager.createComputed(\r\n                    () => fn(),\r\n                    {\r\n                        maxAge: 5 * 60 * 1000, // 5 \u043C\u0438\u043D\u0443\u0442 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432\r\n                        cacheSize: 100 // \u043C\u0435\u043D\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432\r\n                    }\r\n                );\r\n\r\n                Object.defineProperty(computed, key, {\r\n                    get: () => computedProperty(),\r\n                    enumerable: true\r\n                });\r\n            }\r\n\r\n            return computed;\r\n        }\r\n\r\n        setupActions(): ReturnType<A> {\r\n            return actionsFn({\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                computed: this.computed,\r\n                store: storeRegistry,\r\n                el: this,\r\n                slots: this.slots,\r\n            }) as ReturnType<A>;\r\n        }\r\n\r\n        get context(): ComponentContext<InferProps<P>, S, G, C, A> {\r\n            return {\r\n                props: this.getPropValue(),\r\n                state: this.state,\r\n                getters: this.getters,\r\n                computed: this.computed,\r\n                actions: this.actions,\r\n                el: this,\r\n                slots: this.slots,\r\n                store: storeRegistry,\r\n            };\r\n        }\r\n\r\n        initializeProps(): InferProps<P> {\r\n            const props = {} as InferProps<P>;\r\n            for (const [key, definition] of Object.entries(propsDefinition)) {\r\n                const attrName = `data-${key}`;\r\n                const attrValue = this.getAttribute(attrName);\r\n                const defaultValue = definition.default ?? this.getDefaultForType(definition.type);\r\n                props[key as keyof P] = attrValue !== null\r\n                    ? this.parseAttributeValue(attrValue, definition.type)\r\n                    : defaultValue;\r\n            }\r\n            return props;\r\n        }\r\n\r\n        getDefaultForType(type: PropDefinition['type']): any {\r\n            switch (type) {\r\n                case String: return '';\r\n                case Number: return 0;\r\n                case Boolean: return false;\r\n                case Object: return {};\r\n                case Array: return [];\r\n                default: return null;\r\n            }\r\n        }\r\n\r\n        parseAttributeValue(value: string, type: PropDefinition['type']): any {\r\n            switch (type) {\r\n                case Number:\r\n                    return Number(value);\r\n                case Boolean:\r\n                    return value !== null && value !== 'false';\r\n                case Object:\r\n                case Array:\r\n                    try {\r\n                        return JSON.parse(value);\r\n                    } catch {\r\n                        return type === Object ? {} : [];\r\n                    }\r\n                default:\r\n                    return value;\r\n            }\r\n        }\r\n\r\n        attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n            const propName = name.replace(/^data-/, '');\r\n            const propDef = (propsDefinition as any)[propName];\r\n            if (!propDef) return;\r\n            const value = this.parseAttributeValue(newValue, propDef.type);\r\n            this.updateProp(propName as keyof P, value);\r\n        }\r\n\r\n        updateProp(name: keyof P, value: any) {\r\n            this.props.value = {\r\n                ...this.props.peek(),\r\n                [name]: value,\r\n            };\r\n        }\r\n\r\n        getPropValue() {\r\n            return this.props.value;\r\n        }\r\n\r\n        setupListener() {\r\n            if (!listen) return;\r\n\r\n            let previousValue = this.state.peek();\r\n            const cleanup = effect(() => {\r\n                const currentValue = this.state.value;\r\n                listen({\r\n                    ...this.context,\r\n                    newValue: currentValue,\r\n                    oldValue: previousValue\r\n                });\r\n                previousValue = currentValue;\r\n            });\r\n\r\n            this.cleanup.push(cleanup);\r\n        }\r\n\r\n        setupRender() {\r\n            if (!render) return;\r\n\r\n            const cleanup = uRender(this, () => render(this.context));\r\n            this.cleanup.push(cleanup);\r\n        }\r\n\r\n        collectSlots() {\r\n            const slots: Record<string, Node[]> = { default: [] };\r\n            Array.from(this.childNodes).forEach(node => {\r\n                if (node instanceof Element) {\r\n                    const slotName = node.getAttribute('data-slot') || 'default';\r\n                    slots[slotName] = slots[slotName] || [];\r\n                    slots[slotName].push(node);\r\n                } else if (node.textContent?.trim()) {\r\n                    slots.default.push(node);\r\n                }\r\n            });\r\n            this.slots = slots;\r\n        }\r\n\r\n        connectedCallback() {\r\n            requestAnimationFrame(() => {\r\n                this.collectSlots();\r\n                this.setupListener();\r\n                this.setupRender();\r\n                connected?.(this.context);\r\n            })\r\n        }\r\n\r\n        disconnectedCallback() {\r\n            this.cleanup.forEach(cleanup => cleanup());\r\n            this.cleanup = [];\r\n            disconnected?.(this.context);\r\n        }\r\n    }\r\n    if (tagName) {\r\n        customElements.define(tagName, CustomElement);\r\n    }\r\n}"],
  "mappings": "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",
  "names": ["a", "b", "i", "ref", "i", "known", "detail", "hole", "ref", "svg", "a", "b", "c", "u", "t", "template", "direct", "i", "esm_default", "template", "prefix", "i", "_", "hole", "range", "text", "template", "esm_default", "i", "cache", "s", "t", "v", "b", "c", "i", "detail", "svg", "template", "svg", "template", "b", "hole", "svg", "ref", "tag", "template", "remove", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_flags", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "BRAND_SYMBOL", "_refresh", "_unsubscribe", "prev", "next", "subscribe", "fn", "_this", "effect", "prevContext", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "call", "undefined", "_fn", "_globalVersion", "OUTDATED", "err", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "_nextBatchedEffect", "_callback", "finish", "_start", "bind", "_dispose", "a", "b", "i", "cache", "signal", "cached", "detail"]
}
