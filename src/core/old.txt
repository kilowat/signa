import { reactive } from 'uhtml/reactive';
import { effect, ReadonlySignal } from '@preact/signals-core';
import { State, createState, compute } from './state';


// Store types
type StoreModule<S = any, C = any, A = any> = {
    state: State<S>;
    computed: C;
    actions: A;
};

type StoreComputedFn<S> = (context: {
    state: State<S>;
    store: Store;
}) => Record<string, (...args: any[]) => any>;

type StoreComputedProperties<C> = {
    [K in keyof C]: C[K] extends (...args: any[]) => any
    ? ReadonlySignal<ReturnType<C[K]>>
    : never;
};

type StoreActionsFn<S, C extends Record<string, (...args: any[]) => any>> = (context: {
    state: State<S>;
    computed: StoreComputedProperties<C>;
    store: Store;
}) => Record<string, (...args: any[]) => any>;

interface StoreModuleOptions<
    S,
    C extends StoreComputedFn<S>,
    A extends StoreActionsFn<S, ReturnType<C>>
> {
    state?: S;
    computed?: C;
    actions?: A;
}

// Type helper for extracting module type
type RegisteredStoreModule<O> = O extends StoreModuleOptions<
    infer S,
    infer C,
    infer A
>
    ? StoreModule<
        S,
        StoreComputedProperties<ReturnType<C>>,
        ReturnType<A>
    >
    : never;

// Dynamic store type
type Store = {
    [K in string]: StoreModule;
};

// Store singleton
class StoreManager {
    private static instance: StoreManager;
    private modules: Store = {};

    private constructor() { }
    public $<T extends StoreModule>(namespace: string) {
        return this.store[namespace] as T
    }
    static getInstance(): StoreManager {
        if (!this.instance) {
            this.instance = new StoreManager();
        }
        return this.instance;
    }

    registerModule<
        S,
        C extends StoreComputedFn<S>,
        A extends StoreActionsFn<S, ReturnType<C>>
    >(
        namespace: string,
        options: StoreModuleOptions<S, C, A>
    ): RegisteredStoreModule<typeof options> {
        if (this.modules[namespace]) {
            throw new Error(`Module ${namespace} already exists`);
        }

        const state = createState(options.state as S);
        const computed = this.setupComputed(options.computed, state);
        const actions = this.setupActions(options.actions, state, computed);

        const module = { state, computed, actions } as RegisteredStoreModule<typeof options>;
        this.modules[namespace] = module;

        return module;
    }

    private setupComputed<S, C extends StoreComputedFn<S>>(
        computedFn: C | undefined,
        state: State<S>
    ): StoreComputedProperties<ReturnType<C>> {
        if (!computedFn) return {} as StoreComputedProperties<ReturnType<C>>;

        const computedObj = computedFn({ state, store: this.modules });
        return Object.entries(computedObj).reduce((acc, [key, fn]) => ({
            ...acc,
            [key]: compute(state, () => fn())
        }), {}) as StoreComputedProperties<ReturnType<C>>;
    }

    private setupActions<S, C extends StoreComputedFn<S>, A extends StoreActionsFn<S, ReturnType<C>>>(
        actionsFn: A | undefined,
        state: State<S>,
        computed: StoreComputedProperties<ReturnType<C>>
    ): ReturnType<A> {
        if (!actionsFn) return {} as ReturnType<A>;

        const context = {
            state,
            computed,
            store: this.modules
        };

        return actionsFn(context) as ReturnType<A>;
    }

    get store(): Store {
        return this.modules;
    }
}

export const storeManager = StoreManager.getInstance();
// Component types
type ComputedFn<S> = (context: {
    state: State<S>;
    store: Store;
}) => Record<string, (...args: any[]) => any>;

type ActionsFn<S, C> = (context: {
    state: State<S>;
    computed: ComputedProperties<C>;
    store: Store;
}) => Record<string, (...args: any[]) => any>;

type ComputedProperties<C> = {
    [K in keyof C]: C[K] extends (...args: any[]) => any
    ? ReadonlySignal<ReturnType<C[K]>>
    : never;
};

interface BaseContext<S, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>> {
    state: State<S>;
    computed: ComputedProperties<ReturnType<C>>;
    actions: ReturnType<A>;
    store: Store;
}

interface ComponentContext<S, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>>
    extends BaseContext<S, C, A> {
    element: HTMLElement;
    slots: Record<string, Node[]>;
}

interface ListenerParams<S, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>>
    extends ComponentContext<S, C, A> {
    newValue: S;
    oldValue: S;
}

interface ComponentOptions<S, C extends ComputedFn<S>, A extends ActionsFn<S, ReturnType<C>>> {
    tagName: string;
    state?: S;
    computed?: C;
    actions?: A;
    connected?: (context: ComponentContext<S, C, A>) => void;
    render?: (context: ComponentContext<S, C, A>) => unknown;
    listen?: (params: ListenerParams<S, C, A>) => void;
    disconnected?: (context: ComponentContext<S, C, A>) => void;
}

export function defineComponent<
    S,
    C extends ComputedFn<S>,
    A extends ActionsFn<S, ReturnType<C>>
>(options: ComponentOptions<S, C, A>) {
    const {
        tagName,
        state: initialState,
        computed: computedFn,
        actions: actionsFn,
        connected,
        disconnected,
        render,
        listen
    } = options;

    const uRender = reactive(effect);

    class CustomElement extends HTMLElement {
        state: State<S>;
        computed: ComputedProperties<ReturnType<C>>;
        actions: ReturnType<A>;
        slots: Record<string, Node[]> = {};
        cleanup: (() => void)[] = [];

        constructor() {
            super();
            this.state = createState(initialState as S);
            this.computed = this.setupComputed();
            this.actions = this.setupActions();
        }

        get context(): ComponentContext<S, C, A> {
            return {
                state: this.state,
                computed: this.computed,
                actions: this.actions,
                element: this,
                slots: this.slots,
                store: storeManager.store
            };
        }

        setupComputed(): ComputedProperties<ReturnType<C>> {
            if (!computedFn) return {} as ComputedProperties<ReturnType<C>>;

            const computedObj = computedFn({
                state: this.state,
                store: storeManager.store
            });

            return Object.entries(computedObj).reduce((acc, [key, fn]) => ({
                ...acc,
                [key]: compute(this.state, () => fn())
            }), {}) as ComputedProperties<ReturnType<C>>;
        }

        setupActions(): ReturnType<A> {
            if (!actionsFn) return {} as ReturnType<A>;

            const context = {
                state: this.state,
                computed: this.computed,
                store: storeManager.store
            };

            return actionsFn(context) as ReturnType<A>;
        }

        setupListener() {
            if (!listen) return;

            let previousValue = this.state.peek();
            const cleanup = effect(() => {
                const currentValue = this.state.value;
                listen({
                    ...this.context,
                    newValue: currentValue,
                    oldValue: previousValue
                });
                previousValue = currentValue;
            });

            this.cleanup.push(cleanup);
        }

        setupRender() {
            if (!render) return;

            const cleanup = uRender(this, () => render(this.context));
            this.cleanup.push(cleanup);
        }

        collectSlots() {
            const slots: Record<string, Node[]> = { default: [] };

            Array.from(this.childNodes).forEach(node => {
                if (node instanceof Element) {
                    const slotName = node.getAttribute('data-slot') || 'default';
                    slots[slotName] = slots[slotName] || [];
                    slots[slotName].push(node);
                } else if (node.textContent?.trim()) {
                    slots.default.push(node);
                }
            });

            this.slots = slots;
        }

        connectedCallback() {
            this.collectSlots();
            this.setupListener();
            this.setupRender();
            connected?.(this.context);
        }

        disconnectedCallback() {
            this.cleanup.forEach(cleanup => cleanup());
            this.cleanup = [];
            disconnected?.(this.context);
        }
    }

    if (!customElements.get(tagName)) {
        customElements.define(tagName, CustomElement);
    }

    return CustomElement;
}